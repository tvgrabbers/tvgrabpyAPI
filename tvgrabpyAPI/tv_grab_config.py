#!/usr/bin/env python2
# -*- coding: utf-8 -*-

"""
    SYNOPSIS

    tv_grab_py_API is a pythonAPI that trawls several sources for TV
    programming information and outputs it in XMLTV-formatted output (see
    http://wiki.xmltv.org/index.php/XMLTVFormat). Users of MythTV
    (http://www.mythtv.org) will appreciate the output generated by this
    grabber, because it fills the category fields, i.e. colors in the EPG,
    and has logos for most channels automagically available. Check the
    website below for screenshots. It also has extended caching function
    which is ideal for tvheadend users.
    The newest version of this script can be found here:

         https://github.com/tvgrabbers/tvgrabpyAPI/

    USAGE

    Check the web site above and/or run script with --help and start from there

    REQUIREMENTS

    * Python 2.7.9 or higher
    * The pytz module:             http://pypi.python.org/pypi/pytz
    * The requests module:         https://pypi.python.org/pypi/requests
    * The DataTreeGrab module:     https://github.com/tvgrabbers/DataTree/
    * Connection with the Internet

    QUESTIONS

    Questions (and patches) are welcome at:
    https://github.com/tvgrabbers/tvgrabpyAPI/issues
    https://groups.google.com/forum/#!forum/tvgrabnlpy

    UPGRADE NOTES

    If you were using tv_grab_nl from the XMLTV bundle then enable the
    compat flag or use the --compat command-line option.  Otherwise, the
    xmltvid's are wrong and you will not see any new data in MythTV.
    Users of the older standalone version 2.* tv_grab_nl_py script might
    want to enable the legacy_xmltvids option.

    HISTORY

    tv_grab_nl_py used to be called tv_grab_nl_pdb, created by Paul de Bruin
    and first released on 2003/07/09. At the same time the code base switched
    from using CVS to SVN at Google Code, and as a result the version numbering
    scheme has changed. The lastest official release of tv_grab_nl_pdb is 0.48.
    The first official release of tv_grab_nl_py is 6. In 2012, The codebase
    moved to Git, and the version number was changed once more. The latest
    subversion release of tv_grab_nl_py is r109. The first Git release of
    tv_grab_nl_py is 2012-03-11 12:03.

    As of december 2014/ januari 2015 Version 2 a whole new era:
      Upgrading argument processing from getopt to argparse.
      Added genre/subgenre translation table and file (tv_grab_nl_py.set).
        Automatically adding new genre/subgenre combinations on every scan.
        This contains also other translation tables which mostly get updated on
        every scan and gets created with defaults if not existing.
      Added session log function (to the configname with .log added)
        the last log is saved to .old (like with .conf, .opt and .set files)
      Added multiple new sources
      Added ttvdb.com lookup for missing season/episode info
      Added sqlyte caching
      Added multithreading

    In 2016 we are working on transforming tv_grab_nl_py to a generic API:
    tv_grab_py_API which will support multiple frontends. This will move
    tv_grab_nl_py to version 3 and tv_grab_py_API to version 1.

    CONTRIBUTORS

    Main author: Paul de Bruin (paul at pwdebruin dot net)
    Previous maintainer: Freek Dijkstra (software at macfreek dot nl)
    As of 'december 2014':
    Hika van den Hoven hikavdh at gmail dot com, but also active on the
    mythtv list: mythtv-users at mythtv dot org
    Kyle Luna, who especially worked hard on aligning the sources

    Michel van der Laan made available his extensive collection of
    high-quality logos that is used by this script.

    Several other people have provided feedback and patches:
    Huub Bouma, Michael Heus, Udo van den Heuvel, Han Holl, Hugo van der Kooij,
    Roy van der Kuil, Ian Mcdonald, Dennis van Onselen, Remco Rotteveel, Paul
    Sijben, Willem Vermin, Michel Veerman, Sietse Visser, Mark Wormgoor.

    LICENSE

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# Python 3 compatibility
from __future__ import unicode_literals
# from __future__ import print_function

import os, re, sys, argparse, traceback, datetime, time, codecs, pickle
import tv_grab_IO, tv_grab_fetch, tv_grab_channel, pytz
from DataTreeGrab import is_data_value, data_value
from DataTreeGrab import version as dtversion
if dtversion()[1:4] < (1,1,4):
    sys.stderr.write("tv_grab_py_API requires DataTreeGrab 1.1.4 or higher\n")
    sys.exit(2)

try:
    unichr(42)
except NameError:
    unichr = chr    # Python 3

api_name = u'tv_grab_py_API'
api_major = 1
api_minor = 0
api_patch = 0
api_patchdate = u'20160723'
api_alfa = False
api_beta = True

def version():
    return (api_name, api_major, api_minor, api_patch, api_patchdate, api_beta, api_alfa)

def grabber_main(config):
    # We want to handle unexpected errors nicely. With a message to the log
    try:
        if not isinstance(config, Configure):
            return( -2)

        # Get the options, channels and other configuration
        start_time = datetime.datetime.now()
        x = config.validate_commandline()
        if x != None:
            return(x)

        config.log(config.text('config', 5, (start_time.strftime('%Y-%m-%d %H:%M'), ), 'other'),4, 1)

        # Start the seperate fetching threads
        for source in config.channelsource.values():
            x = source.start()
            if x != None:
                return(x)

        # Start the Channel threads, but wait a second so the sources have properly initialized any child channel
        time.sleep(1)
        counter = 0
        channel_threads = []
        for channel in config.channels.values():
            if not (channel.active or channel.is_child):
                continue

            counter += 1
            channel.counter = counter
            x = channel.start()
            if x != None:
                return(x)

            channel_threads.append(channel)

        # Synchronize
        for index in config.detail_sources:
            config.channelsource[index].join()

        for channel in channel_threads:
            if channel.is_alive():
                channel.join()

        # produce the results and wrap-up
        config.write_defaults_list()
        config.xml_output.print_string()

        # Create a report
        end_time = datetime.datetime.now()
        config.write_statistics(start_time, end_time)

    except:
        #~ traceback.print_exc()
        config.logging.log_queue.put({'fatal': [traceback.format_exc(), '\n'], 'name': None})
        return(99)

    # and return success
    return(0)
# end grabber_main()

class Configure:

    def __init__(self):
        # Version info as returned by the version function
        self.api_name = api_name
        self.api_major = api_major
        self.api_minor = api_minor
        self.api_patch = api_patch
        self.api_patchdate = api_patchdate
        self.api_alfa = api_alfa
        self.api_beta = api_beta
        try:
            x = self.name

        except AttributeError:
            # No name was set in the frontend
            self.name ='tv_grab_configure.py'
            self.log(u'No valid Frontend Name set! Setting it to "%s"\n' % (self.name, ))

        self.major = self.api_major
        self.minor = self.api_minor
        self.patch = self.api_patch
        self.patchdate = self.api_patchdate
        self.alfa = self.api_alfa
        self.beta = self.api_beta
        self.utc_tz = pytz.utc
        self.output_tz = self.utc_tz
        self.compat_text = ''
        self.opt_dict = {}
        self.user_agents = [ 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.9) Gecko/20071025 Firefox/2.0.0.9',
               'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.19) Gecko/20081216 Ubuntu/8.04 (hardy) Firefox/2.0.0.19',
               'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',
               'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A',
               'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 7.0; InfoPath.3; .NET CLR 3.1.40767; Trident/6.0; en-IN)',
               'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.0) Gecko/20100101 Firefox/42.0',
               'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36',
               'Mozilla/5.0 (X11; Linux x86_64; rv:38.0) Gecko/20100101 Firefox/38.0']

        # Some debug Flags
        self.write_info_files = False
        self.only_local_sourcefiles = False
        self.infofiles = None

        self.log_output = None
        self.httpencoding = 'iso-8859-15'
        self.file_encoding = 'utf-8'

        # Create a category translation dictionary
        # Look in mythtv/themes/blue/ui.xml for all category names
        # The keys are the categories used by tvgids.nl (lowercase please)
        # See the file ~/.xmltv/tv_grab_nl_py.set created after the first run and edit there!
        self.cattrans = {}
        self.genre_list = []
        self.cattranstype = {}
        self.cattranstype[0] = {}
        self.cattranstype[1] = {}
        self.cattranstype[2] = {}

        from tvgrabpyAPI import __path__
        self.api_path = __path__[0]
        self.opt_dict['home_dir'] = ''
        self.opt_dict['etc_dir'] = u'/etc/tvgrabpyAPI'
        self.opt_dict['var_dir'] = u'/var/lib/tvgrabpyAPI'
        self.api_source_url = 'https://raw.githubusercontent.com/tvgrabbers/sourcematching/master'
        self.api_update_url = 'https://github.com/tvgrabbers/tvgrabnlpy/releases/latest'
        self.source_url = self.api_source_url
        self.update_url = self.api_update_url
        self.source_dir =  self.opt_dict['var_dir']
        if 'HOME' in os.environ:
            self.opt_dict['home_dir'] = os.environ['HOME']
        elif 'HOMEPATH' in os.environ:
            self.opt_dict['home_dir'] = os.environ['HOMEPATH']

        if os.name == 'nt' and 'USERPROFILE' in os.environ:
            self.opt_dict['home_dir'] = os.environ['USERPROFILE']
        self.as_root = (self.opt_dict['home_dir'] == '/root')
        self.opt_dict['xmltv_dir'] = u'%s/.xmltv' % self.opt_dict['home_dir']
        if os.name == 'nt':
            self.source_dir = u'%s/sources' % self.opt_dict['xmltv_dir']
            self.opt_dict['sources'] = self.source_dir
        elif self.as_root:
            self.opt_dict['xmltv_dir'] = self.opt_dict['etc_dir']
            self.opt_dict['sources'] = self.source_dir
        else:
            self.opt_dict['sources'] = u'%s/sources' % self.opt_dict['xmltv_dir']

        self.opt_dict['config_file'] = u'%s/%s.conf' % (self.opt_dict['xmltv_dir'], self.name)
        self.opt_dict['log_file'] = u'%s/%s.log' % (self.opt_dict['xmltv_dir'], self.name)
        self.opt_dict['settings_file'] = u'%s/%s.set' % (self.opt_dict['xmltv_dir'], self.name)
        self.opt_dict['cache_file'] = u'%s/program_cache3' % self.opt_dict['xmltv_dir']
        self.program_cache = None
        self.clean_cache = True
        self.clear_cache = False
        self.output = None

        self.opt_dict['language'] = 'en'
        self.opt_dict['nice_time'] = [1, 2]
        self.opt_dict['graphic_frontend'] = False
        self.opt_dict['log_level'] = 175
        self.opt_dict['match_log_level'] = 11
        self.opt_dict['mail_log'] = False
        self.opt_dict['mailserver'] = 'localhost'
        self.opt_dict['mailport'] = 25
        self.opt_dict['mail_log_address'] = 'postmaster'
        self.opt_dict['mail_info_address'] = None
        self.opt_dict['output_file'] = None
        self.opt_dict['global_timeout'] = 10
        self.opt_dict['max_simultaneous_fetches'] = 5
        self.opt_dict['group_active_channels'] = False
        self.opt_dict['always_use_json'] = True
        self.opt_dict['quiet'] = False
        self.opt_dict['fast'] = False
        self.opt_dict['offset'] = 0
        self.opt_dict['days'] = 14
        self.opt_dict['slowdays'] = None
        self.opt_dict['disable_source'] = []
        self.opt_dict['disable_detail_source'] = []
        self.opt_dict['disable_ttvdb'] = False
        self.opt_dict['compat'] = False
        self.opt_dict['legacy_xmltvids'] = False
        self.opt_dict['max_overlap'] = 10
        self.opt_dict['overlap_strategy'] = 'average'
        self.opt_dict['logos'] = True
        self.opt_dict['desc_length'] = 475
        self.opt_dict['cattrans'] = True
        self.opt_dict['mark_hd'] = False
        self.opt_dict['use_utc'] = False
        self.opt_dict['use_split_episodes'] = True
        self.opt_dict['ratingstyle'] = 'short'

        self.detail_keys = {}
        self.detail_keys['all'] = []
        self.detail_keys['ttvdb'] = []
        self.detail_keys['episodes'] = []
        self.texts = {}
        self.logging = None
        self.threads = []
        self.queues = {}
        self.logging = tv_grab_IO.Logging(self)
        self.IO_func = tv_grab_IO.Functions(self)
        self.fetch_func = tv_grab_fetch.Functions(self)
        self.xml_output = tv_grab_channel.XMLoutput(self)
        self.channelsource = {}
        self.sourceid_by_name = {}
        self.ttvdb = None

        self.queues['log'] = self.logging.log_queue
        self.queues['source'] = {}
        self.queues['channel'] = {}
        self.channels = {}
        self.chan_count = 0

        self.lang = 'en'
        self.language = None
        self.texts = None
        self.load_text(self.lang)
        self.description = self.text('config', 0, type='other')
        self.configversion = None
        self.__CONFIG_SECTIONS__ = { 1: u'Configuration',
                                                            2: u'tvgids.nl Channels',
                                                            3: u'Channels'}


        self.__DEFAULT_SECTIONS__ = {1: u'genre conversion table',
                                                             2: u'no title split list',
                                                             3: u'remove groupname list',
                                                             4: u'rename title list',
                                                             5: u'genres to get detail pages for'}

    # end Init()

    def version(self, as_string = False, API = False):
        """
        return tuple or string with version info
        """
        if API:
            if as_string and self.alfa:
                return u'%s (%s: %s.%s.%s-p%s-alpha)' % (self.api_name, self.text('config', 6, type = 'other'), self.api_major, self.api_minor, '{:0>2}'.format(self.api_patch), self.api_patchdate)

            if as_string and self.api_beta:
                return u'%s (%s: %s.%s.%s-p%s-beta)' % (self.api_name, self.text('config', 6, type = 'other'), self.api_major, self.api_minor, '{:0>2}'.format(self.api_patch), self.api_patchdate)

            if as_string and not self.api_beta:
                return u'%s (%s: %s.%s.%s-p%s)' % (self.api_name, self.text('config', 6, type = 'other'), self.api_major, self.api_minor, '{:0>2}'.format(self.api_patch), self.api_patchdate)

            else:
                return (self.api_name, self.api_major, self.api_minor, self.api_patch, self.api_patchdate, self.api_beta, self.api_alfa)

        else:
            if as_string and self.alfa:
                return u'%s (%s: %s.%s.%s-p%s-alpha)' % (self.name, self.text('config', 6, type = 'other'), self.major, self.minor, '{:0>2}'.format(self.patch), self.patchdate)

            if as_string and self.beta:
                return u'%s (%s: %s.%s.%s-p%s-beta)' % (self.name, self.text('config', 6, type = 'other'), self.major, self.minor, '{:0>2}'.format(self.patch), self.patchdate)

            if as_string and not self.beta:
                return u'%s (%s: %s.%s.%s-p%s)' % (self.name, self.text('config', 6, type = 'other'), self.major, self.minor, '{:0>2}'.format(self.patch), self.patchdate)

            else:
                return (self.name, self.major, self.minor, self.patch, self.patchdate, self.beta, self.alfa)

    # end version()

    def log(self, message, log_level = 1, log_target = 3):
        # If logging not (jet) available, make sure important messages go to the screen
        if (self.logging.log_output == None) and (log_level < 2) and (log_target & 1):
            if isinstance(message, (str, unicode)):
                sys.stderr.write(message.encode(self.logging.local_encoding, 'replace'))

            elif isinstance(message, (list ,tuple)):
                for m in message:
                    sys.stderr.write(m.encode(self.logging.local_encoding, 'replace'))

            if log_target & 2:
                self.logging.log_queue.put([message, log_level, 2])

        else:
            self.logging.log_queue.put([message, log_level, log_target])

    # end log()

    def load_text(self, lang = 'en'):
        if lang == self.lang and self.texts != None:
            return

        name = 'tv_grab_text'
        fle_name = u'%s/texts/%s.%s' % (self.api_path, name, lang)
        try:
            if os.path.isfile(fle_name):
                fle_dict = pickle.load(open(fle_name,'r'))
                self.lang = fle_dict['lang']
                self.language = fle_dict['language']
                if self.texts == None:
                    self.texts = fle_dict['texts']

                else:
                    for module in fle_dict['texts'].keys():
                        if not is_data_value([module], self.texts, dict):
                            self.texts[module] = {}

                        for type in fle_dict['texts'][module].keys():
                            if not is_data_value([module, type], self.texts, dict):
                                self.texts[module][type] = {}

                            for tno in fle_dict['texts'][module][type].keys():
                                if is_data_value(['texts', module, type, tno], fle_dict, str, True):
                                    self.texts[module][type][tno] = data_value(['texts', module, type, tno], fle_dict, str)

                self.log(self.texts['config']['error'][-2])

            else:
                self.log('Error loading language file: %s.%s\n' % (name, lang))

        except:
            self.log('Error loading language file: %s.%s\n' % (name, lang))

    # end load_text()

    def text(self, module = 'sources', tno = 0, addintuple = None, type = 'error', return_empty_on_missing = False):
        try:
            if is_data_value([module, type, tno], self.texts, str):
                txt = data_value([module, type, tno], self.texts, str)
                if isinstance(addintuple, tuple) and len(addintuple) > 0:
                    txt = txt % addintuple

                return txt

            elif return_empty_on_missing:
                return u''

            else:
                return self.texts['config']['error'][0] % (module, type, tno)

        except:
            return u'xError creating message text! (%s, %s: %s)\n' % (module, type, tno)
    # end text()

    def in_tz(self, cdate, tz = None):
        if tz == None:
            tz = pyz.utc

        if isinstance(cdate, datetime.datetime):
            if cdate.tzinfo == None:
                return tz.localize(cdate)

            else:
                return tz.normalize(cdate.astimezone(tz))

    def in_utc(self, cdate):
        return self.in_tz(cdate, self.utc_tz)

    def in_output_tz(self, cdate):
        return self.in_tz(cdate, self.output_tz)

    def in_fetch_tz(self, cdate):
        return self.in_tz(cdate, self.fetch_tz)

    # end in_tz()

    def init_sources(self, sid = None):
        """Initialize the sources named in sourcematching"""
        def disable_source(s):
            # Disable the source as no data file is supplied
            self.log(self.text('config', 1,(s, )))
            self.validate_option('disable_source', value = s)
            self.channelsource[s] = tv_grab_fetch.FetchData(self, s, None)
            if s in self.source_order[:]:
                self.source_order.remove(s)

            if s in self.sourceid_order[:]:
                self.sourceid_order.remove(s)

            if s in self.prime_source_order[:]:
                self.prime_source_order.remove(s)

            if s in self.detail_sources[:]:
                self.detail_sources.remove(s)

        def init_source(sid, v):
            if not 'json file' in v:
                disable_source(sid)
                return

            dversion = data_value('version', v, int, 0)
            dversion = v['version'] if ('version' in v and isinstance(v["version"], int)) else 0
            jurl = v["json_url"] if ("json_url" in v and isinstance(v["json_url"], (str, unicode))) else self.source_url
            sdata = self.fetch_func.get_json_data(v['json file'], dversion, sid, jurl, self.opt_dict['sources'])
            if sdata == None:
                disable_source(sid)
                return

            raw_json = self.fetch_func.raw_json[v['json file']]
            if raw_json != '':
                dv = sdata["version"] if ("version" in sdata and isinstance(sdata["version"], int)) else 0
                # The file was downloaded. Check if it is already saved locally
                fle = self.IO_func.open_file('%s/%s.%s.json' % (self.opt_dict['sources'], v['json file'], dv), 'w', 'utf-8')
                if fle != None:
                    fle.write(raw_json)
                    fle.close()

            ctype = v["cattrans type"] if ("cattrans type" in v and isinstance(v["cattrans type"], int)) else None
            self.channelsource[sid] = tv_grab_fetch.FetchData(self, sid, sdata, ctype)
            if ctype == None:
                return self.channelsource[sid]

            if not ctype in self.cattranstype.keys():
                self.cattranstype[ctype] = {}

            if "cattransid" in v and isinstance(v["cattransid"], int):
                self.__DEFAULT_SECTIONS__[10 + v["cattransid"]] = u'%s genres' % (self.channelsource[sid].source)
                self.cattranstype[ctype][10 + v["cattransid"]] = sid
                if ctype == 1:
                    self.channelsource[sid].new_cattrans = {}
                elif ctype == 2:
                    self.channelsource[sid].new_cattrans = []

            return self.channelsource[sid]

        if sid == None:
            for s, v in self.sources.items():
                init_source(s, v)

        elif sid in self.sources.keys():
            return init_source(sid, self.sources[sid])

    # end init_sources()

    def validate_commandline(self):
        """Read the commandline and validate the values"""
        if self.read_commandline() == 0:
             return(0)

        # The Query options
        for (a, o) in ((self.args.version, 'version'), \
                              (self.args.description, 'description'), \
                              (self.args.description_long, 'description_long'), \
                              (self.args.capabilities, 'capabilities'), \
                              (self.args.preferredmethod, 'preferredmethod')):
            if a:
                self.validate_option(o)
                return(0)

        # Check config and log files
        if self.args.config_file != self.opt_dict['config_file']:
            # use the provided name for configuration and logging
            self.opt_dict['config_file'] = self.args.config_file
            self.opt_dict['log_file'] = self.args.config_file+'.log'

        x = self.validate_option('config_file')
        if x != None:
            return(x)

        self.only_local_sourcefiles = self.args.only_cache
        x = self.get_json_datafiles(self.args.configure)
        if x != None:
            return(x)

        self.init_sources()
        # The Source Query options
        for (a, o) in ((self.args.show_sources, 'show_sources'), \
                              (self.args.show_logo_sources, 'show_logo_sources'), \
                              (self.args.show_detail_sources, 'show_detail_sources')):
            if a:
                self.validate_option(o)
                return(0)

        if self.as_root and not self.args.configure:
            # Not allowed to run as root except to configure
            self.log([self.text('config', 2)])
            return(0)

        if self.args.quiet != None:
            self.opt_dict['quiet'] = self.args.quiet

        if self.args.disable_ttvdb != None:
            self.opt_dict['disable_ttvdb'] = self.args.disable_ttvdb

        self.validate_option('ttvdb', value = 'v1')
        #check for cache
        if self.validate_option('cache_file') != None:
            return(2)

        if self.args.clear_cache or self.args.clear_ttvdb:
            return(0)

        if self.args.ttvdb_title != None :
            return self.validate_option('check_ttvdb_title')

        # Check a possible output file
        if self.args.output_file != None:
            self.opt_dict['output_file'] = self.args.output_file

        if self.validate_option('output_file') != None:
            return(2)

        # Validate the options
        for s in self.args.disable_source:
            self.validate_option('disable_source', value = s)

        for s in self.args.disable_detail_source:
            self.validate_option('disable_detail_source', value = s)

        if self.args.only_cache:
            self.args.fast = True
            self.args.slowdays  = 0

        for (a, o) in ((self.args.compat, 'compat'), \
                              (self.args.legacy_xmltvids, 'legacy_xmltvids'), \
                              (self.args.fast, 'fast'), \
                              (self.args.logos, 'logos'), \
                              (self.args.mark_hd, 'mark_hd'), \
                              (self.args.cattrans, 'cattrans'), \
                              (self.args.slowdays, 'slowdays'), \
                              (self.args.desc_length, 'desc_length'), \
                              (self.args.overlap_strategy, 'overlap_strategy'), \
                              (self.args.max_overlap, 'max_overlap')):
            if a != None:
                self.opt_dict[o] = a
                for chanid in self.channels.keys():
                    self.channels[chanid].opt_dict[o] = self.opt_dict[o]

        self.offset = self.opt_dict['offset']
        for (a, o) in ((self.args.use_utc, 'use_utc'), \
                              (self.args.offset, 'offset'), \
                              (self.args.days, 'days')):
            if a != None:
                self.opt_dict[o] = a

        # limit days to maximum supported by the several sites
        for o in ('offset', 'days'):
            self.validate_option(o)

        # Continue validating the settings for the individual channels
        for chanid in self.channels.keys():
            self.channels[chanid].validate_settings()

        if not self.args.configure and self.configversion < float('%s.%s' % (self.api_major+2, self.api_minor)):
            # Update to the current version config
            if self.configversion == 1.0:
                self.write_defaults_list()

            if not self.write_config(None):
                self.log([self.text('config', 3), self.text('config', 4)])
                return(1)

            self.log([self.text('config', 5, (self.opt_dict['config_file'], )), \
                self.text('config', 6), self.text('config', 7)], 1, 1)
            return(0)

        self.write_opts_to_log()
        if self.args.configure:
            self.args.group_active_channels = self.opt_dict['group_active_channels'] | self.args.group_active_channels
            self.log(self.text('config', 8,(self.opt_dict['config_file'], )))
            if self.get_channels() == 69:
                return 69

            if not self.write_config(True):
                self.log(self.text('config', 9))
                self.IO_func.restore_oldfile(self.opt_dict['config_file'])
                return(1)

            self.log([self.text('config', 10, (self.opt_dict['config_file'], )), \
                self.text('config', 6), self.text('config', 7)], 1, 1)
            return(0)

        if self.args.save_options:
            if not self.write_config(False):
                self.log(self.text('config', 9))
                self.IO_func.restore_oldfile(self.opt_dict['config_file'])
                return(1)

            self.log([self.text('config', 11, (self.opt_dict['config_file'], )), self.text('config', 6)])
            return(0)

        self.read_defaults_list()

    # end validate_commandline()

    def validate_option(self, option, channel = None, value = None, stdoutput = True, check_default = False):
        """Validate an option"""
        if not (channel == None or channel in self.channels.values()):
            return

        if option == 'version':
            print("%s: %s" % (self.country, self.version(True)))
            print("The Netherlands: %s" % self.version(True, True))
            return(0)

        elif option == 'description':
            v=self.version()
            if v[6]:
                dtext = ("%s v%s.%s.%s-alfa" % (self.description, v[1], v[2], v[3]))

            elif v[5]:
                dtext = ("%s v%s.%s.%s-beta" % (self.description, v[1], v[2], v[3]))

            else:
                dtext = ("%s v%s.%s.%s" % (self.description, v[1], v[2], v[3]))

            if stdoutput:
                print(dtext)

            else:
                return(dtext)

        elif option == 'description_long':
            print("The Netherlands: %s" % self.version(True))
            print(__doc__)
            return(0)

        elif option == 'capabilities':
            if stdoutput:
                print("baseline")
                print("cache")
                print("manualconfig")
                print("preferredmethod")

            else:
                return ("baseline", "cache", "manualconfig", "preferredmethod")

        elif option == 'preferredmethod':
            if stdoutput:
                 print('allatonce')

            else:
                 return('allatonce')

        elif option == 'show_sources':
            if stdoutput:
                print(self.text('config', 1, type='other'))
                for i, s in self.channelsource.items():
                    print('  %s: %s' % (i, s.source))

            else:
                tdict = {}
                for i, s in self.channelsource.items():
                    tdict[i] = s.source

                return tdict

        elif option == 'show_detail_sources':
            if stdoutput:
                print(self.text('config', 2, type='other'))
                for i, s in self.channelsource.items():
                    if i in self.detail_sources:
                        print('  %s: %s' % (i, s.source))

            else:
                tdict = {}
                for i, s in self.channelsource.items():
                    if s.detail_processor:
                        tdict[i] = s.source

                return tdict
        elif option == 'show_logo_sources':
            self.get_json_datafiles(show_info=False)
            if stdoutput:
                print(self.text('config', 3, type='other'))
                for k, v in self.xml_output.logo_provider.items():
                    print('  %s: %s' % (k, v))

                print(self.text('config', 4, type='other'))

            else:
                tdict = {}
                for k, v in self.xml_output.logo_provider.items():
                    tdict[k] = v

                    tdict[99] = 'free-form'
                return tdict

        elif option == 'check_ttvdb_title':
            if self.opt_dict['disable_ttvdb']:
                self.log(self.text('ttvdb', 1))
                return(-2)

            if len(self.args.ttvdb_title) == 0:
                self.log(self.text('ttvdb', 2))
                return(-2)

            series_title = unicode(self.args.ttvdb_title[0], 'utf-8')
            lang = self.xml_language
            if len(self.args.ttvdb_title) >1:
                lang = unicode(self.args.ttvdb_title[1], 'utf-8')[:2]
                if not lang in self.ttvdb.lang_list:
                    self.log(self.text('ttvdb', 3, (lang,)))
                    lang = 'en'

            return self.ttvdb.check_ttvdb_title(series_title, lang)

        elif option == 'disable_source':
            if value in self.channelsource.keys():
                if channel == None:
                    if value not in self.opt_dict['disable_source']:
                        self.opt_dict['disable_source'].append(value)

                elif channel.get_source_id(value) != '':
                    if value not in channel.opt_dict['disable_source']:
                        channel.opt_dict['disable_source'].append(value)

                    if value in self.detail_sources and value not in channel.opt_dict['disable_detail_source']:
                        channel.opt_dict['disable_detail_source'].append(value)

        elif option == 'disable_detail_source':
            if value in self.detail_sources:
                if channel == None:
                    if value not in self.opt_dict['disable_detail_source']:
                        self.opt_dict['disable_detail_source'].append(value)

                elif channel.get_source_id(value) != '':
                    if value not in channel.opt_dict['disable_detail_source']:
                        channel.opt_dict['disable_detail_source'].append(value)

        elif option == 'prime_source':
            if channel == None:
                return

            # First get the default
            def_value = -1
            if channel.group in self.prime_source_groups and channel.get_source_id(self.prime_source_groups[channel.group]) != '' \
                and not (self.prime_source_groups[channel.group] in self.opt_dict['disable_source'] \
                or self.prime_source_groups[channel.group] in channel.opt_dict['disable_source'] \
                or channel.get_source_id(self.prime_source_groups[channel.group]) in self.channelsource[self.prime_source_groups[channel.group]].no_genric_matching):
                    # A group default in sourcematching.json
                    def_value = self.prime_source_groups[channel.group]

            else:
                for s in self.prime_source_order:
                    if channel.get_source_id(s) != '' \
                        and not (s in self.opt_dict['disable_source'] or s in channel.opt_dict['disable_source'] \
                        or channel.get_source_id(s) in self.channelsource[s].no_genric_matching):
                            # The first available not set in no_genric_matching
                            def_value = s
                            break

                else:
                    for s in self.prime_source_order:
                        if channel.get_source_id(s) != '' \
                            and not (s in self.opt_dict['disable_source'] or s in channel.opt_dict['disable_source']):
                                # The first available
                                def_value = s
                                break

            # Now we check for a custom value
            if value == None:
                value = channel.opt_dict['prime_source']

            custom_value = None
            if value in self.channelsource.keys() and channel.get_source_id(value) != '' \
                and not (value in self.opt_dict['disable_source'] or value in channel.opt_dict['disable_source']) \
                and value != def_value:
                    # It's a valid custom value not equal to the default
                    custom_value = value

            json_value = None
            if channel.chanid in self.prime_source.keys() and channel.get_source_id(self.prime_source[channel.chanid]) != '' \
                and not (self.prime_source[channel.chanid] in self.opt_dict['disable_source'] \
                or self.prime_source[channel.chanid] in channel.opt_dict['disable_source']):
                    # Use an override in sourcematching.json
                    json_value = self.prime_source[channel.chanid]

            if self.opt_dict['always_use_json']:
                for v in (json_value, custom_value):
                    if v != None and not channel.get_source_id(v) in self.channelsource[v].no_genric_matching:
                        value = v
                        break

                else:
                    value = def_value

            else:
                for v in (custom_value, json_value):
                    if v != None and not channel.get_source_id(v) in self.channelsource[v].no_genric_matching:
                        value = v
                        break

                else:
                    value = def_value

            if check_default:
                return bool((value == def_value) or (value == -1))

            else:
                channel.opt_dict['prime_source'] = value

        elif option == 'prefered_description':
            if channel == None:
                return

            if value == None:
                value = channel.opt_dict['prefered_description']

            if value in self.channelsource.keys() and channel.get_source_id(value) != '' \
                and not (value in self.opt_dict['disable_source'] or value in channel.opt_dict['disable_source']):
                    channel.opt_dict['prefered_description'] = value

            else:
                channel.opt_dict['prefered_description'] = -1

        elif option == 'offset':
            if self.opt_dict['offset'] > 14:
                if self.offset < 14:
                    self.log(self.text('config', 12, (self.opt_dict['offset'], self.offset)),1,1)
                    self.opt_dict['offset'] = self.offset

                else:
                    self.log(self.text('config', 12, (self.opt_dict['offset'], '0')),1,1)
                    self.opt_dict['offset'] = 0

        elif option == 'days':
            if self.opt_dict['days'] > (14 - self.opt_dict['offset']):
                self.log(self.text('config', 13),1,1)

            self.opt_dict['days'] = min(self.opt_dict['days'],(14 - self.opt_dict['offset']))

            if self.opt_dict['slowdays'] == None or self.opt_dict['slowdays'] > self.opt_dict['days']:
                self.opt_dict['slowdays'] = self.opt_dict['days']

        elif option == 'output_file':
            if self.opt_dict['output_file'] != None:
                try:
                    output_dir = os.path.dirname(self.opt_dict['output_file'])
                    if (output_dir != '') and not os.path.exists(output_dir):
                        self.log(self.text('config', 14, (output_dir, )))
                        os.mkdir(output_dir)

                    if self.args.output_codeset:
                        self.xml_output.xmlencoding = 'CP1252'
                        self.output = self.IO_func.open_file(self.opt_dict['output_file'],'w', 'windows-1252')

                    else:
                        self.output = self.IO_func.open_file(self.opt_dict['output_file'],'w')

                    if self.output == None:
                        self.log(self.text('config', 15, (self.opt_dict['output_file'],)))
                        return(2)

                except:
                    self.log([self.text('config', 15, (self.opt_dict['output_file'],)), traceback.format_exc()])
                    return(2)

            else: self.output = None

        elif option == 'config_file':
            # Save an old session log and open a new one
            try:
                # check for the config/log dir
                config_dir = os.path.dirname(self.opt_dict['config_file'])
                if (config_dir != '') and not os.path.exists(config_dir):
                    self.log(self.text('config', 14, (config_dir,)))
                    os.mkdir(config_dir)

                else:
                    self.IO_func.save_oldfile(self.opt_dict['log_file'])

            except:
                self.logging.writelog(self.text('config', 16, (config_dir, )), 0,1)
                self.logging.writelog(traceback.format_exc(), 0,1)
                return(2)

            try:
                self.log_output = self.IO_func.open_file(self.opt_dict['log_file'], mode = 'a')
                if self.log_output == None:
                    self.logging.writelog(self.text('config', 17, (self.opt_dict['log_file'], )), 0,1)
                    return(2)

                self.logging.start()

            except:
                self.logging.writelog(traceback.format_exc(), 0,1)
                self.logging.writelog(self.text('config', 17, (self.opt_dict['log_file'], )), 0,1)
                return(2)

            self.log(self.text('config', 18, (self.opt_dict['config_file'], )))
            # get config if available Overrule if set by commandline
            if not self.read_config() and not self.args.configure:
                self.opt_dict['config_file'] = u'%s/%s.conf' % (self.opt_dict['etc_dir'], self.name)
                self.log([self.text('config', 19, (self.opt_dict['config_file'], ))])
                if not self.read_config():
                    return(1)

        elif option == 'cache_file':
            if self.args.cache_file != self.opt_dict['cache_file']:
                self.opt_dict['cache_file'] = self.args.cache_file

            if self.opt_dict['cache_file'].lower() == 'none' or self.opt_dict['cache_file'] == None:
                self.opt_dict['cache_file'] = None
                self.program_cache = tv_grab_IO.ProgramCache(self, self.opt_dict['cache_file'])
                self.program_cache.start()
                return

            try:
                cache_dir = os.path.dirname(self.opt_dict['cache_file'])
                if (cache_dir != '') and not os.path.exists(cache_dir):
                    self.log(self.text('config', 14, (cache_dir, )))
                    os.mkdir(cache_dir)

                if not (os.access(self.opt_dict['cache_file'], os.F_OK and os.W_OK) \
                    or (not os.path.isfile(self.opt_dict['cache_file']) and os.access(cache_dir, os.W_OK))):
                    self.log(self.text('config', 20, (self.opt_dict['cache_file'], )))
                    return(2)

            except:
                self.log([self.text('config', 21, (self.opt_dict['cache_file'], )), traceback.format_exc()])
                return(2)

            self.program_cache = tv_grab_IO.ProgramCache(self, self.opt_dict['cache_file'])
            self.program_cache.start()
            if self.args.clear_cache:
                self.program_cache.cache_request.put({'task':'clear'})

            elif self.args.clean_cache:
                self.program_cache.cache_request.put({'task':'clean'})

            if self.args.clear_ttvdb:
                self.program_cache.cache_request.put({'task':'clear', 'table':['ttvdb', 'episodes']})

        elif option == 'ttvdb':
            if self.opt_dict['disable_ttvdb'] or not is_data_value([value, 'json file'], self.ttvdb_json, str):
                self.opt_dict['disable_ttvdb'] = True
                return

            jfile = data_value([value, 'json file'], self.ttvdb_json, str)
            dversion = data_value([value, 'version'], self.ttvdb_json, int, 0)
            jurl = data_value([value, 'json_url'], self.ttvdb_json, str, self.source_url)
            sdata = self.fetch_func.get_json_data(jfile, dversion, -1, jurl, self.opt_dict['sources'])
            if sdata == None:
                self.opt_dict['disable_ttvdb'] = True
                return

            raw_json = self.fetch_func.raw_json[jfile]
            if raw_json != '':
                dv = data_value(["version"], sdata, int, 0)
                # The file was downloaded. Check if it is already saved locally
                fle = self.IO_func.open_file('%s/%s.%s.json' % (self.opt_dict['sources'], jfile, dv), 'w', 'utf-8')
                if fle != None:
                    fle.write(raw_json)
                    fle.close()

            if value == 'v1':
                self.ttvdb = tv_grab_fetch.theTVDB_v1(self, sdata)

            #~ elif value == 'v2':
                #~ self.ttvdb = tv_grab_fetch.theTVDB_v2(self, sdata)

            else:
                self.opt_dict['disable_ttvdb'] = True
                return

            self.ttvdb.start()

        elif option == 'slowdays':
            if channel == None:
                if self.opt_dict['slowdays'] == None:
                    self.opt_dict['slowdays'] = self.opt_dict['days']
                    if self.opt_dict['desc_length'] == 0:
                        # no description implies fast == True
                        if not self.opt_dict['fast']:
                            self.log(self.text('config', 22),1,1)
                            self.opt_dict['fast'] = True

                else:
                    self.opt_dict['slowdays'] = min(self.opt_dict['days'], self.opt_dict['slowdays'])
                    # slowdays implies fast == False
                    if self.opt_dict['slowdays'] < self.opt_dict['days']:
                        self.opt_dict['fast']  = False

            else:
                if channel.opt_dict['slowdays'] == None:
                    channel.opt_dict['slowdays'] = self.opt_dict['days']
                    if channel.opt_dict['desc_length'] == 0:
                        # no description implies fast == True
                        if not channel.opt_dict['fast']:
                            self.log(self.text('config', 23, (channel.chan_name, )),1,1)
                            channel.opt_dict['fast'] = True

                else:
                    channel.opt_dict['slowdays'] = min(self.opt_dict['days'], channel.opt_dict['slowdays'])
                    # slowdays implies fast == False
                    if channel.opt_dict['slowdays'] < self.opt_dict['days']:
                        channel.opt_dict['fast']  = False

        elif option == 'desc_length':
            if channel != None and channel.opt_dict['desc_length'] != self.opt_dict['desc_length']:
                self.log(self.text('config', 24, (channel.opt_dict['desc_length'], channel.chan_name)),1,1)

        elif option == 'overlap_strategy':
            if channel == None:
                if not self.opt_dict['overlap_strategy'] in ['average', 'stop', 'start']:
                    self.opt_dict['overlap_strategy'] = 'none'

            else:
                if not channel.opt_dict['overlap_strategy'] in ['average', 'stop', 'start']:
                    channel.opt_dict['overlap_strategy'] = 'none'

        elif option == 'max_overlap':
            if channel == None:
                if self.opt_dict['max_overlap'] == 0:
                    # no max_overlap implies strategie == 'None'
                    self.opt_dict['overlap_strategy'] = 'None'
                    self.log(self.text('config', 25, (self.opt_dict['overlap_strategy'], )),1,1)

            elif channel.opt_dict['max_overlap'] == 0:
                # no max_overlap implies strategie == 'None'
                channel.opt_dict['overlap_strategy'] = 'None'
                self.log(self.text('config', 26, (channel.chan_name, channel.opt_dict['overlap_strategy'])),1,1)

            elif channel.opt_dict['max_overlap'] != self.opt_dict['max_overlap']:
                self.log(self.text('config', 27, (channel.opt_dict['max_overlap'], channel.chan_name)),1,1)
                if channel.opt_dict['overlap_strategy'] != self.opt_dict['overlap_strategy']:
                    self.log(self.text('config', 28, (channel.chan_name, channel.opt_dict['overlap_strategy'])),1,1)

    # end validate_option()

    def read_commandline(self):
        """Initiate argparser and read the commandline"""
        index = 0
        if '-l' in sys.argv:
            index = sys.argv.index('-l') + 1

        elif '--language' in sys.argv:
            index = sys.argv.index('--language') + 1

        if index > 0 and is_data_value(index, sys.argv, str) and sys.argv[index] != 'en' and len(sys.argv[index]) == 2:
                self.load_text(sys.argv[index].lower())

        def check_lang(lang):
            name = 'tv_grab_text'
            fle_name = u'%s/texts/%s.%s' % (self.api_path, name, lang)
            try:
                if os.path.isfile(fle_name):
                    return lang

                else:
                    raise argparse.ArgumentTypeError('"%s" is not a supported language' % lang)

            except:
                raise argparse.ArgumentTypeError('"%s" is not a supported language' % lang)

        description = u"%s: %s\n" % (self.country, self.version(True)) + \
                        u"The Netherlands: %s\n" % self.version(True, True) + \
                        self.text('config', 1, type = 'help') + self.text('config', 2, type = 'help')

        parser = argparse.ArgumentParser(description = description, formatter_class=argparse.RawTextHelpFormatter, add_help=False)

        parser.add_argument('-h', '--help', action = 'store_true', default = False, dest = 'help',
                        help = self.text('config', 3, type='help'))

        parser.add_argument('-l', '--language', type = check_lang, default = 'en', dest = 'language',
                        metavar = '<lang code>', help =self.text('config', 47, type='help'))

        parser.add_argument('-V', '--version', action = 'store_true', default = False, dest = 'version',
                        help = self.text('config', 5, type='help'))

        parser.add_argument('--description', action = 'store_true', default = False, dest = 'description',
                        help =self.text('config', 6, type='help'))

        parser.add_argument('-d', '--long-descr', action = 'store_true', default = False, dest = 'description_long',
                        help =self.text('config', 7, type='help'))

        parser.add_argument('--capabilities', action = 'store_true', default = False, dest = 'capabilities',
                        help =self.text('config', 8, type='help'))

        parser.add_argument('--preferredmethod', action = 'store_true', default = False, dest = 'preferredmethod',
                        help =self.text('config', 9, type='help'))

        parser.add_argument('--show-sources', action = 'store_true', default = False, dest = 'show_sources',
                        help =self.text('config', 10, type='help'))

        parser.add_argument('--show-detail-sources', action = 'store_true', default = False, dest = 'show_detail_sources',
                        help =self.text('config', 12, type='help'))

        parser.add_argument('--show-logo-sources', action = 'store_true', default = False, dest = 'show_logo_sources',
                        help =self.text('config', 13, type='help'))

        parser.add_argument('--disable-source', action = 'append', default = [], dest = 'disable_source',
                        metavar = '<source ID>', type = int, help =self.text('config', 11, type='help'))

        parser.add_argument('--disable-detail-source', action = 'append', default = [], dest = 'disable_detail_source',
                        metavar = '<source ID>', type = int, help =self.text('config', 15, type='help'))

        parser.add_argument('--disable-ttvdb', action = 'store_true', default = None, dest = 'disable_ttvdb',
                        help =self.text('config', 16, type='help'))

        parser.add_argument('--add-ttvdb-title', nargs = '*', metavar = '<title>', dest = 'ttvdb_title',
                        help =self.text('config', 17, type='help'))

        parser.add_argument('-x', '--compat', action = 'store_true', default = None, dest = 'compat',
                        help =self.text('config', 18, (self.compat_text,), type='help'))

        if self.name =='tv_grab_nl3_py':
            parser.add_argument('-X', '--legacy_xmltvids', action = 'store_true', default = None, dest = 'legacy_xmltvids',
                        help =self.text('config', 19, type='help'))

        parser.add_argument('-u', '--utc', action = 'store_true', default = None, dest = 'use_utc',
                        help =self.text('config', 20, type='help'))

        parser.add_argument('-c', '--configure', action = 'store_true', default = False, dest = 'configure',
                        help =self.text('config', 21, type='help'))

        parser.add_argument('--group_active_channels', action = 'store_true', default = False, dest = 'group_active_channels',
                        help =self.text('config', 22, type='help'))

        parser.add_argument('-C', '--config-file', type = str, default = self.opt_dict['config_file'], dest = 'config_file',
                        metavar = '<file>', help =self.text('config', 23, (self.opt_dict['config_file'], ), type='help'))

        parser.add_argument('-O', '--save-options', action = 'store_true', default = False, dest = 'save_options',
                        help =self.text('config', 24, type='help'))

        parser.add_argument('-A', '--cache', type = str, default = self.opt_dict['cache_file'], dest = 'cache_file',
                        metavar = '<file>', help =self.text('config', 25, (self.opt_dict['cache_file'], ), type='help'))

        parser.add_argument('-U', '--use-only-cache', action = 'store_true', default = False, dest = 'only_cache',
                        help =self.text('config', 48, type='help'))

        parser.add_argument('--clean_cache', action = 'store_true', default = self.clean_cache, dest = 'clean_cache',
                        help =self.text('config', 26, type='help'))

        parser.add_argument('--clear_cache', '--clear-cache', action = 'store_true', default = self.clear_cache, dest = 'clear_cache',
                        help =self.text('config', 27, type='help'))

        parser.add_argument('--clear_ttvdb', '--clear-ttvdb', action = 'store_true', default = self.clear_cache, dest = 'clear_ttvdb',
                        help =self.text('config', 28, type='help'))

        parser.add_argument('-W', '--output', type = str, default = None, dest = 'output_file',
                        metavar = '<file>', help =self.text('config', 29, type='help'))

        parser.add_argument('--output-windows-codeset',  action = 'store_true', default = False, dest = 'output_codeset',
                        help =self.text('config', 30, type='help'))

        parser.add_argument('-q', '--quiet', action = 'store_true', default = None, dest = 'quiet',
                        help =self.text('config', 31, type='help'))

        parser.add_argument('-v', '--verbose', action = 'store_false', default = None, dest = 'quiet',
                        help =self.text('config', 32, type='help'))

        parser.add_argument('-f', '--fast', action = 'store_true', default = None, dest = 'fast',
                        help =self.text('config', 33, type='help'))

        parser.add_argument('-s', '--slow', action = 'store_false', default = None, dest = 'fast',
                        help =self.text('config', 34, type='help'))

        parser.add_argument('-o', '--offset', type = int, default = None, dest = 'offset', choices=range(0, 14),
                        metavar = '<days>', help =self.text('config', 35, type='help'))

        parser.add_argument('-g', '--days', type = int, default = None, dest = 'days', choices=range(0, 14),
                        metavar = '<days>', help =self.text('config', 36, type='help'))

        parser.add_argument('-G', '--slowdays', type = int, default = None, dest = 'slowdays', choices=range(0, 14),
                        metavar = '<days>', help =self.text('config', 38, type='help'))

        parser.add_argument('--logos', action = 'store_true', default = None, dest = 'logos',
                        help =self.text('config', 39, type='help'))

        parser.add_argument('-n', '--nologos', action = 'store_false', default = None, dest = 'logos',
                        help =self.text('config', 40, type='help'))

        parser.add_argument('-H', '--mark-HD', action = 'store_true', default = None, dest = 'mark_hd',
                        help =self.text('config', 41, type='help'))

        parser.add_argument('--cattrans', action = 'store_true', default = None, dest = 'cattrans',
                        help =self.text('config', 42, (self.name,), type='help'))

        parser.add_argument('-t', '--nocattrans', action = 'store_false', default = None, dest = 'cattrans',
                        help =self.text('config', 43, type='help'))

        parser.add_argument('-l ', '--desc-length', type = int, default = None, dest = 'desc_length',
                        metavar = '<bytes>', help =self.text('config', 44, type='help'))

        parser.add_argument('-a', '--overlap_strategy', type = str, default = None, dest = 'overlap_strategy',
                        choices=['average', 'stop', 'start', 'none'], metavar = '<strategy>', help =self.text('config', 45, type='help'))

        parser.add_argument('-m', '--max_overlap', type = int, default = None, dest = 'max_overlap',
                        metavar = '<minutes>', help =self.text('config', 46, type='help'))

        # Handle the sys.exit(0) exception on --help more gracefull
        try:
            self.args = parser.parse_args()

            if self.args.help:
                parser.print_help()
                return(0)

        except:
            return(0)
    # end read_commandline()

    def read_config(self):
        """Read the configurationfile Return False on failure."""
        self.config_dict = {1:[], 2:[], 3:[], 9:{}}
        f = self.IO_func.open_file(self.opt_dict['config_file'])
        if f == None:
            if not self.args.configure:
                self.log(self.text('config', 31))
            return False

        if not self.IO_func.check_encoding(f, None, True):
            return False

        self.encoding = self.IO_func.encoding
        self.configversion = self.IO_func.configversion
        if self.configversion == 1.0:
            type = 2
            section = self.__CONFIG_SECTIONS__[2]

        else:
            type = 0
            section = ''
            if self.configversion < 2.208:
                self.log(self.text('config', 32), 0)
                self.opt_dict['legacy_xmltvids'] = True
                if not self.args.configure:
                    self.log(self.text('config', 33), 0)

        # Read the configuration into the self.config_dict dictionary
        f.seek(0,0)
        for byteline in f.readlines():
            try:
                line = self.IO_func.get_line(f, byteline, None, self.encoding)
                if not line:
                    continue

                if line[0:1] == '#' and type != 3:
                    continue

                # Look for section headers
                config_title = re.search('\[(.*?)\]', line)
                if config_title != None:
                    if (config_title.group(1) in self.__CONFIG_SECTIONS__.values()):
                        section = config_title.group(1)
                        for i, v in self.__CONFIG_SECTIONS__.items():
                            if v == config_title.group(1):
                                type = i
                                continue

                        continue

                    # It a channel confuration
                    elif config_title.group(1)[0:7].lower() == 'channel':
                        section = config_title.group(1)[7:].strip().lower()
                        type = 9
                        if not section in self.config_dict[9].keys():
                            self.config_dict[9][section] = []
                        continue

                    # Unknown Section header, so ignore
                    else:
                        self.log(self.text('config', 34, (config_title.group(1), )))
                        section = ''
                        type = 0

                # Unknown Section header, so ignore
                elif line[0:1] == '[':
                    section = ''
                    type = 0
                    continue

                if type in (1, 2, 3):
                    self.config_dict[type].append(line)

                elif type == 9:
                    self.config_dict[9][section].append(line)

                else:
                    self.log(self.text('config', 35, (line, )))


            except:
                self.log([self.text('config', 36), traceback.format_exc()])
                continue

        f.close()
        # Read the General Configuration options
        for line in self.config_dict[1]:
            try:
                # Strip the name from the value
                a = re.split('=',line)
                cfg_option = a[0].lower().strip()
                if cfg_option == 'language' and len(a) == 2:
                    self.load_text(a[1].lower().strip())

                # Boolean Values
                if cfg_option in ('write_info_files', 'quiet', 'fast', 'compat', 'logos', 'cattrans', 'mail_log', \
                  'mark_hd', 'use_utc', 'disable_ttvdb', 'use_split_episodes', 'group_active_channels', \
                  'always_use_json', 'legacy_xmltvids'):
                    if len(a) == 1:
                        self.opt_dict[cfg_option] = True

                    elif a[1].lower().strip() in ('true', '1' , 'on'):
                        self.opt_dict[cfg_option] = True

                    else:
                        self.opt_dict[cfg_option] = False

                # String values that can be None
                elif cfg_option in ('output_file', 'mail_info_address'):
                    self.opt_dict[cfg_option] = None if (len(a) == 1 or a[1].lower().strip() == 'none') else a[1].strip()

                elif len(a) == 2:
                    cfg_value = a[1].lower().strip()
                    # String values
                    if cfg_option in ('mailserver', 'mail_log_address', 'output_tz'):
                        self.opt_dict[cfg_option] = a[1].strip()

                    # Select Values
                    elif cfg_option == 'overlap_strategy':
                        if cfg_value in ('average', 'stop', 'start'):
                            self.opt_dict[cfg_option] = cfg_value

                        else:
                            self.opt_dict[cfg_option] = 'none'

                    elif cfg_option in ('ratingstyle', 'kijkwijzerstijl'):
                        if cfg_value in ('long', 'short', 'single'):
                            self.opt_dict['ratingstyle'] = cfg_value

                        else:
                            self.opt_dict['ratingstyle'] = 'none'

                    # Integer Values
                    elif cfg_option in ('log_level', 'match_log_level', 'offset', 'days', 'slowdays', 'mailport', \
                      'max_overlap', 'desc_length', 'disable_source', 'disable_detail_source', 'data_version', \
                      'max_simultaneous_fetches', 'global_timeout'):
                        try:
                            cfg_value = int(cfg_value)

                        except ValueError:
                            if (cfg_option == 'slowdays') and (cfg_value == 'none'):
                                self.opt_dict[cfg_option] = None

                        else:
                            if cfg_option in ('disable_source', 'disable_detail_source'):
                                self.validate_option(cfg_option, value = cfg_value)

                            else:
                                self.opt_dict[cfg_option] = cfg_value

            except:
                self.log([self.text('config', 37, (self.opt_dict['config_file'],)),'%r\n' % (line)])

        # Read the channel stuff up to version 2.0
        channel_names = {}
        old_chanids = {}
        if self.configversion <= 2.0:
            for line in self.config_dict[2]:
                try:
                    channel = line.split(None, 1) # split on first whitespace
                    self.channels[unicode(channel[0]).strip()] = tv_grab_channel.Channel_Config(self, unicode(channel[0]).strip(), unicode(channel[1]).strip())
                    self.channels[unicode(channel[0]).strip()].active = True
                    channel_names[unicode(channel[1]).strip().lower()] = unicode(channel[0]).strip()

                except:
                    self.log([self.text('config', 38, (self.opt_dict['config_file'], )),'%r\n' % (line)])

        # Changed Channel config since version 2.1
        if self.configversion >= 2.1:
            test_as_21 = False
            for line in self.config_dict[3]:
                try:
                    if line[0:1] == '#':
                        active = False
                        line = line.lstrip('#').lstrip()

                    else:
                        active = True

                    channel = re.split(';', line)
                    if len(channel) < 6:
                        # A configuration line with less then six has no chanids
                        continue

                    # Test to catch early 2.2 configurations without a chanid
                    try:
                        if self.configversion > 2.1:
                            if channel[2].strip() == '':
                                test_as_21 = True

                            else:
                                x = int(channel[2])
                                test_as_21 = True

                    except:
                        pass

                    if self.configversion == 2.1 or test_as_21:
                        # Read an old channel string
                        if len(channel) != 8 and not test_as_21:
                            # A 2.1  configuration line must contain 8 items
                            continue

                        for index in range(4):
                            if channel[index + 2].strip() != '':
                                old_chanid = unicode(channel[index + 2]).strip()
                                break

                        else:
                            # No sources!
                            continue

                        chanid = u'%s-%s' % (index, old_chanid)
                        old_chanids[old_chanid] = chanid
                        self.channels[chanid] = tv_grab_channel.Channel_Config(self, chanid, unicode(channel[0]).strip(), int(channel[1]))
                        for index in range(4):
                            if index == 0:
                                self.channels[chanid].source_id[3] = unicode(channel[index + 2]).strip()

                            else:
                                self.channels[chanid].source_id[index] = unicode(channel[index + 2]).strip()

                    else:
                        # And the new version 2.2 one
                        for index in range(len(channel) - 5):
                            if channel[index + 3].strip() != '':
                                break

                        else:
                            # No sources!
                            continue

                        chanid = unicode(channel[2])
                        channel_names[unicode(channel[0]).strip().lower()] = chanid
                        self.channels[chanid] = tv_grab_channel.Channel_Config(self, chanid, unicode(channel[0]).strip(), int(channel[1]))
                        for index in range(len(channel) - 5):
                            if self.configversion < 3.0 and index in (0, 3):
                                if index == 0:
                                    self.channels[chanid].source_id[3] = unicode(channel[index + 3]).strip()

                            else:
                                self.channels[chanid].source_id[index] = unicode(channel[index + 3]).strip()

                    # The icon defenition
                    self.channels[chanid].icon_source = int(channel[-2])
                    self.channels[chanid].icon = unicode(channel[-1]).strip()
                    # fill in the default options
                    for i, v in self.opt_dict.items():
                        if i in self.channels[chanid].opt_dict.keys() and not i in ('disable_source', 'disable_detail_source'):
                            self.channels[chanid].opt_dict[i] = v

                    # Set active if not remarked out
                    self.channels[chanid].active = active
                    if active:
                        self.chan_count += 1

                except:
                    self.log([self.text('config', 38, (self.opt_dict['config_file'], )),'%r\n' % (line), traceback.format_exc()])

            # Read the channel specific configuration
            for section, values in self.config_dict[9].items():
                if self.configversion == 2.1 or test_as_21:
                    if section in old_chanids.keys():
                        chanid = old_chanids[section]

                    else:
                        continue

                # is the name in the sectionheader a known chanid?
                elif section in self.channels.keys():
                    chanid = section

                # or a known channelname
                elif section in channel_names.keys():
                    chanid = channel_names[section]

                else:
                    # unknown chanid or channelname
                    self.log(self.text('config', 39, (section, )))
                    continue

                for line in values:
                    try:
                        # Strip the name from the value
                        a = re.split('=',line)
                        cfg_option = a[0].lower().strip()
                        # Boolean Values
                        if cfg_option in ('fast', 'compat', 'logos', 'cattrans', 'mark_hd', 'add_hd_id', \
                          'disable_ttvdb', 'use_split_episodes', 'legacy_xmltvids'):
                            if len(a) == 1:
                                self.channels[chanid].opt_dict[cfg_option] = True

                            elif a[1].lower().strip() in ('true', '1' , 'on'):
                                self.channels[chanid].opt_dict[cfg_option] = True

                            else:
                                self.channels[chanid].opt_dict[cfg_option] = False

                        elif len(a) == 2:
                            cfg_value = a[1].lower().strip()
                            if cfg_option == 'use_npo':
                                if cfg_value in ('false', '0' , 'off'):
                                    self.validate_option('disable_source', self.channels[chanid], 4)

                            # String values
                            elif cfg_option in ('xmltvid_alias', ):
                                self.channels[chanid].opt_dict[cfg_option] = cfg_value.strip()

                            # Select Values
                            elif cfg_option == 'overlap_strategy':
                                if cfg_value in ('average', 'stop', 'start'):
                                    self.channels[chanid].opt_dict[cfg_option] = cfg_value

                                else:
                                    self.channels[chanid].opt_dict[cfg_option] = 'none'

                            # Integer Values
                            elif cfg_option in ('slowdays', 'max_overlap', 'desc_length'):
                                try:
                                    cfg_value = int(cfg_value)

                                except ValueError:
                                    if (cfg_option == 'slowdays') and (cfg_value == 'none'):
                                        self.channels[chanid].opt_dict[cfg_option] = None

                                else:
                                    self.channels[chanid].opt_dict[cfg_option] = cfg_value

                            # Source Values
                            elif cfg_option in ('prime_source', 'prefered_description', 'disable_source', 'disable_detail_source'):
                                try:
                                    cfg_value = int(cfg_value)

                                except ValueError:
                                    continue

                                else:
                                    if cfg_option == 'prime_source':
                                        # We have to validate this value after reading sourcematching.json
                                        self.channels[chanid].prevalidate_opt[cfg_option] = cfg_value

                                    else:
                                        self.validate_option(cfg_option, self.channels[chanid], cfg_value)

                    except:
                        self.log([self.text('config', 40, (section, self.opt_dict['config_file'], )),'%r\n' % (line), traceback.format_exc()])

        # an extra option for gathering extra info to better the code
        if 'write_info_files' in self.opt_dict.keys():
            self.write_info_files = self.opt_dict['write_info_files']
            if self.write_info_files :
                self.infofiles = tv_grab_IO.InfoFiles(self)

        if 'output_tz' in self.opt_dict.keys():
            try:
                self.output_tz = pytz.timezone(self.opt_dict['output_tz'])

            except:
                if not isinstance(self.output_tz, datetime.tzinfo):
                    self.output_tz = self.utc_tz

        return True
    # end read_config()

    def read_defaults_list(self):
        """
        Get the genre conversion table, the title split exception list and others
        """
        f = self.IO_func.open_file(self.opt_dict['settings_file'])
        if f == None:
            return False

        if not self.IO_func.check_encoding(f):
            return False

        self.encoding = self.IO_func.encoding
        f.seek(0,0)
        type = 0
        for byteline in f.readlines():
            try:
                line = self.IO_func.get_line(f, byteline, False, self.encoding)
                if not line:
                    continue

                # Look for section headers
                config_title = re.search('\[(.*?)\]', line)
                if config_title != None and (config_title.group(1) in self.__DEFAULT_SECTIONS__.values()):
                    for i, v in self.__DEFAULT_SECTIONS__.items():
                        if v == config_title.group(1):
                            type = i
                            if type in self.cattranstype[1].keys():
                                source = self.cattranstype[1][type]
                                if not source in self.channelsource.keys():
                                    type = 0

                            elif type in self.cattranstype[2].keys():
                                source = self.cattranstype[2][type]
                                if not source in self.channelsource.keys():
                                    type = 0

                            continue

                    # Ignore the defaults if section exists
                    if type == 3:
                        self.groupnameremove = []

                    elif type == 4:
                        self.titlerename = {}

                    elif type == 5:
                        self.detailed_genres = []

                    continue

                # Unknown Section header, so ignore
                if line[0:1] == '[':
                    type = 0
                    continue

                if type == 1:
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        a.append('')

                    # split main and sub-genre (if present) and if they have a translation
                    # (overwriting the default) or are not jet pressent add them to cattrans
                    g = re.split(':', a[0].lower() )
                    if len(g) == 2:
                        if not ((g[0].strip(), g[1].strip()) in self.cattrans and a[1].strip() == ''):
                            self.cattrans[(g[0].strip(), g[1].strip())] = a[1].strip()

                    elif len(g) == 1:
                        if not ((g[0].strip(), g[1].strip()) in self.cattrans and a[1].strip() == ''):
                            self.cattrans[(g[0].strip(), '')] = a[1].strip()

                elif type == 2:
                    line = line.lower()
                    if not line in self.notitlesplit:
                        self.notitlesplit.append(line)

                elif type == 3:
                    line = line.lower()
                    if not line in self.groupnameremove:
                        self.groupnameremove.append(line)

                elif type == 4:
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        continue

                    self.titlerename[a[0].lower().strip()] = a[1].strip()

                elif type == 5:
                    line = line.lower()
                    if not line in self.detailed_genres:
                        self.detailed_genres.append(line)

                elif type in self.cattranstype[1].keys():
                    # split of the translation (if present) or supply an empty one
                    a = line.split('=',1)
                    gg = a[0].split(':',1)
                    if len(a) == 1:
                        tg = [self.cattrans_unknown.lower().strip(),'']

                    else:
                        tg = a[1].split(':',1)

                    if len(tg) == 1:
                        tg.append('')

                    if not gg[0].lower().strip() in self.channelsource[source].cattrans.keys():
                        self.channelsource[source].cattrans[gg[0].lower().strip()] = {}

                    if len(gg) < 2 or gg[1].strip() == '':
                        self.channelsource[source].cattrans[gg[0].lower().strip()]['default'] = tg

                    else:
                        self.channelsource[source].cattrans[gg[0].lower().strip()][gg[1].lower().strip()] = tg

                elif type in self.cattranstype[2].keys():
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        continue

                    if len(a[1]) > 20:
                        continue

                    self.channelsource[source].cattrans[a[1].lower().strip()] = a[0].strip()

            except:
                self.log([self.text('config', 41, (self.opt_dict['settings_file'], )), traceback.format_exc()])
                continue

        f.close()
        self.groupnameremove.sort(key=lambda p: len(p), reverse = True)
        return True

    #end read_defaults_list()

    def get_json_datafiles(self, configuring = False, show_info = True):
        # This gets grabed after reading the config
        def is_gitdata_value(searchpath, dtype = None):
            return is_data_value(searchpath, githubdata, dtype, True)

        def gitdata_value(searchpath, dtype = None, default = None):
            return data_value(searchpath, githubdata, dtype, default)

        def gitdata_dict(gvar, intlevels = 0):
            def get_int_keys(ivar, level):
                if not isinstance(ivar, dict) or level < 1:
                    return ivar

                lvar = {}
                for k, v in ivar.items():
                    try:
                        lvar[int(k)] = get_int_keys(v, level -1)

                    except:
                        lvar[k] = get_int_keys(v, level -1)

                return lvar

            if not is_gitdata_value(gvar, dict):
                return {}

            return get_int_keys( githubdata[gvar], intlevels)

        def log_failure():
            self.log([self.text('config', 43), traceback.format_exc()], 0)
            if configuring:
                self.log([self.text('config', 44)], 0)

        try:
            if not os.path.exists(self.opt_dict['sources']):
                os.mkdir(self.opt_dict['sources'])

        except:
            pass

        try:
            githubdata = self.fetch_func.get_json_data('tv_grab_API', fpath = self.opt_dict['sources'])
            if not isinstance(githubdata, dict):
                log_failure()
                return 2

            raw_json = self.fetch_func.raw_json['tv_grab_API']
            if raw_json != '':
                fle = self.IO_func.open_file('%s/%s.json' % (self.opt_dict['sources'], 'tv_grab_API'), 'w', 'utf-8')
                if fle != None:
                    fle.write(raw_json)
                    fle.close()

            # Check on program updates
            nv = gitdata_value("program_version", str, '1.0.0')
            pv = u'%s.%s.%s' % (self.api_major, self.api_minor, self.api_patch)
            if not "data_version" in self.opt_dict:
                self.opt_dict["data_version"] = 0

            if pv < nv or (pv == nv and (self.alfa or self.beta)):
                loglist = [self.text('config', 8, type = 'other')]
                if is_gitdata_value("version_message", str):
                    loglist.append(githubdata["version_message"])

                elif is_gitdata_value("version_message", list):
                    loglist.extend(githubdata["version_message"])

                loglist.append(self.text('config', 9, (self.api_update_url,  ), type = 'other'))
                if show_info:
                    self.log(loglist, 0)

        except:
            log_failure()
            #~ traceback.print_exc()
            return 2

        # Read in the tables needed for normal grabbing
        self.key_values = gitdata_dict("data_keys")
        self.tuple_values = gitdata_dict("tuple_values")
        self.xml_output.logo_provider = gitdata_dict("logo_provider", 1)
        self.xml_output.logo_source_preference = gitdata_value("logo_source_preference", list)
        self.ttvdb_aliasses = gitdata_dict("ttvdb_aliasses")
        self.coutrytrans = gitdata_dict("coutrytrans")
        self.notitlesplit = gitdata_value("notitlesplit", list)
        self.user_agents = gitdata_value("user_agents", list, self.user_agents)
        self.ttvdb_json = gitdata_dict("ttvdb")
        for k in self.xml_output.logo_provider.keys():
            if k not in self.xml_output.logo_source_preference:
                self.xml_output.logo_source_preference.append(k)

        try:
            githubdata = self.fetch_func.get_json_data(self.datafile, url = self.source_url, fpath = self.opt_dict['sources'])
            if not isinstance(githubdata, dict):
                log_failure()
                return 2

            raw_json = self.fetch_func.raw_json[self.datafile]
            if raw_json != '':
                fle = self.IO_func.open_file('%s/%s.json' % (self.opt_dict['sources'], self.datafile), 'w', 'utf-8')
                if fle != None:
                    fle.write(raw_json)
                    fle.close()

            # Check on data updates
            nv = gitdata_value("program_version", str, '1.0.0')
            pv = u'%s.%s.%s' % (self.major, self.minor, self.patch)
            dv = gitdata_value("data_version", int, 0)
            if not "data_version" in self.opt_dict:
                self.opt_dict["data_version"] = 0

            if pv < nv or (pv == nv and (self.alfa or self.beta)):
                loglist = [self.text('config', 10, type = 'other')]
                if is_gitdata_value("version_message", str):
                    loglist.append(githubdata["version_message"])

                elif is_gitdata_value("version_message", list):
                    loglist.extend(githubdata["version_message"])

                loglist.append(self.text('config', 9, (self.update_url, ), type = 'other'))
                if show_info:
                    self.log(loglist, 0)

            elif dv > self.opt_dict["data_version"]:
                loglist = [self.text('config', 11, type = 'other')]
                if is_gitdata_value("warning_message", dict):
                    for v in githubdata["warning_message"].keys():
                        if int(v) > self.opt_dict["data_version"]:
                            if is_gitdata_value(["warning_message", v], str):
                                loglist.append(gitdata_value(["warning_message", v], str))

                            elif is_gitdata_value(["warning_message", v], list):
                                loglist.extend(gitdata_value(["warning_message", v], list))

                if not configuring:
                    loglist.append(self.text('config', 12, type = 'other'))

                if show_info:
                    self.log(loglist, 0)

        except:
            log_failure()
            #~ traceback.print_exc()
            return 2

        source_url = gitdata_value("source-url", str, self.source_url)
        if source_url in (None, ''):
            self.source_url = u'%s/sources' % self.source_url

        else:
            self.source_url = source_url

        self.sources = gitdata_dict("sources", 1)
        self.source_count = max(self.sources.keys()) + 1
        # Check on disabled sources
        active_sources = gitdata_value("active_sources", list)
        self.sourceid_order = gitdata_value("sourceid_order", list)
        self.detail_sources = gitdata_value("detail_sources", list)
        for c in self.sources.keys():
            if c not in active_sources:
                self.validate_option('disable_source', value = c)

        # Remove any source that's not (jet) there
        self.source_order = active_sources[:]
        for s in active_sources:
            if not s in self.sources.keys():
                self.source_order.remove(s)

        # Remove any source that's not (jet) there
        self.prime_source_order = gitdata_value("prime_source_order", list)
        for s in self.prime_source_order[:]:
            if not s in self.sources.keys():
                self.prime_source_order.remove(s)

        self.fetch_tz = gitdata_value("fetch-timezone", str, 'UTC')
        self.xml_language = gitdata_value("language", str, 'en').lower()
        try:
            self.fetch_tz = pytz.timezone(self.fetch_tz)
        except:
            self.fetch_tz = pytz.utc

        self.source_channels = gitdata_dict("source_channels", 1)
        self.prime_source = gitdata_dict("prime_source")
        # Remove any source that's not (jet) there
        for c, s in self.prime_source.items():
            if s not in self.sources.keys():
                del self.prime_source[c]

        self.prime_source_groups = gitdata_dict("prime_source_groups", 1)
        # Remove any source that's not (jet) there
        for g, s in self.prime_source_groups.items():
            if s not in self.sources.keys():
                del self.prime_source_groups[g]
        logo_provider = gitdata_dict("logo_provider", 1)
        for k, v in logo_provider.items():
            if k > 100:
                self.xml_output.logo_provider[k] = v
                self.xml_output.logo_source_preference.append(k)

        ttvdb_aliasses = gitdata_dict("ttvdb_aliasses")
        for k, v in ttvdb_aliasses.items():
            self.ttvdb_aliasses[k] = v

        self.channel_rename = gitdata_dict("channel_rename")
        self.chan_groups = gitdata_dict("channel_groups", 1)
        self.group_order = gitdata_value("group_order", list)
        self.group_language = gitdata_dict("group language", 1)
        for g in self.chan_groups.keys():
            if g not in self.group_order[:]:
                self.group_order.append(g)

        for g in self.group_order:
            if g not in self.chan_groups.keys():
                self.chan_groups[g] = 'Channel groep %s' % g

            if g not in self.group_language.keys():
                self.group_language[g] = 'en'

        self.ttvdb_langs = gitdata_value("ttvdb langs", list, ['en'])
        self.ttvdb_disabled_groups = gitdata_value("ttvdb disable groups", list)
        self.channel_grouping = gitdata_dict("channel_grouping", 1)
        logo_names = gitdata_dict("logo_names")
        self.xml_output.logo_names = {}
        for k, icon in logo_names.items():
            if k == "--description--":
                continue

            if len(icon[1].split('.')) == 1:
                self.xml_output.logo_names[k] = [int(icon[0]), icon[1] + '.png']

            else:
                self.xml_output.logo_names[k] = [int(icon[0]), icon[1]]

        self.combined_channels_tz = gitdata_value("combined-channels-tz", str, 'UTC')
        try:
            self.combined_channels_tz = pytz.timezone(self.combined_channels_tz)
        except:
            self.combined_channels_tz = pytz.utc

        combined_channels = gitdata_dict("combined_channels")
        self.combined_channels = {}
        for chanid, chanlist in combined_channels.items():
            if chanid == "--description--":
                continue

            with_timings = False
            for child in chanlist:
                if isinstance(child, dict) and 'chanid' in child and ('start' in child or 'end' in child):
                    with_timings = True

            clist = []
            for child in chanlist:
                if isinstance(child, dict) and 'chanid' in child:
                    if 'start' in child:
                        try:
                            st = child['start'].split(':')
                            child['start'] = datetime.time(int(st[0]), int(st[1]))
                        except:
                            self.log(self.text('config', 45, (child['chanid'], chanid)))
                            del child['start']

                    if 'end' in child:
                        try:
                            st = child['end'].split(':')
                            child['end'] = datetime.time(int(st[0]), int(st[1]))
                        except:
                            self.log(self.text('config', 46, (child['chanid'], chanid)))
                            del child['end']

                    if not 'end' in child and ('start' in child or with_timings):
                        child['end'] = datetime.time(23, 59)

                    if not 'start' in child and ('end' in child or with_timings):
                        child['start'] = datetime.time(0, 0)

                    clist.append(child)

                elif isinstance(child, (str, unicode)):
                    clist.append({'chanid': child})

            if len(clist) > 0:
                self.combined_channels[chanid] = clist

        #~ if configuring:
            #~ self.opt_dict["data_version"] = dv

        logarray = []
        self.merge_into = gitdata_dict("merge_into")
        for newch, oldch  in self.merge_into.items():
            if newch == "--description--":
                continue

            newpresent = bool(newch in self.channels)
            newactive = newpresent and self.channels[newch].active
            oldpresent = bool(oldch['chanid'] in self.channels)
            oldactive = oldpresent and self.channels[oldch['chanid']].active
            if configuring:
                if oldpresent:
                    logarray.append(self.text('config', 1, (oldch['chanid'], newch, ), type = 'mergeinfo'))
                    logarray.extend(oldch['message'])
                    # Initiate an alias if the old chanid is active
                    if oldactive and newactive:
                        logarray.append(self.text('config', 2, type = 'mergeinfo'))
                        logarray.append(self.text('config', 3, (oldch['chanid'], ), type = 'mergeinfo'))
                        logarray.append(self.text('config', 4, type = 'mergeinfo'))
                        logarray.append('  xmltvid_alias = %s\n' % oldch['chanid'])
                        logarray.append(self.text('config', 5, (newch, ), type = 'mergeinfo'))

                    elif oldactive and self.channels[newch].opt_dict['xmltvid_alias'] == None:
                        logarray.append(self.text('config', 6, type = 'mergeinfo'))
                        logarray.append('  xmltvid_alias = %s\n' % oldch['chanid'])
                        logarray.append(self.text('config', 7, (newch, ), type = 'mergeinfo'))
                        self.channels[newch].opt_dict['xmltvid_alias'] = oldch['chanid']
                        self.channels[newch].active = True

                    elif oldactive:
                        logarray.append(self.text('config', 8, (newch, ), type = 'mergeinfo'))
                        logarray.append(self.text('config', 9, type = 'mergeinfo'))
                        logarray.append(self.text('config', 10, (oldch['chanid'], ), type = 'mergeinfo'))
                        logarray.append(self.text('config', 11, type = 'mergeinfo'))
                        logarray.append('  xmltvid_alias = %s\n' % self.channels[newch].opt_dict['xmltvid_alias'])
                        logarray.append(self.text('config', 12, type = 'mergeinfo'))
                        logarray.append('  xmltvid_alias = %s\n' % oldch['chanid'])
                        logarray.append(self.text('config', 13, (newch, ), type = 'mergeinfo'))
                        self.channels[newch].active = True

                    self.channels[oldch['chanid']].active = False
                    logarray.append(self.text('config', 14, (oldch['chanid'], ), type = 'mergeinfo'))
                    logarray.append(self.text('config', 15, (newch, ), type = 'mergeinfo'))
                    logarray.append('\n')

                for source, id in oldch['sources'].items():
                    # Link the ids from the old chanid to the new chanid
                    if oldch['chanid'] in self.source_channels[int(source)]:
                        self.source_channels[int(source)][newch] = self.source_channels[int(source)][oldch['chanid']]
                        del self.source_channels[int(source)][oldch['chanid']]

            else:
                if newpresent:
                    # Remove the old one from combined_channels if in there
                    if newch in self.combined_channels.keys():
                        for c in self.combined_channels[newch]:
                            if c['chanid'] == oldch['chanid']:
                                self.combined_channels[newch].remove(c)
                                break

                    # And link the ids to the new chanid
                    for source, id in oldch['sources'].items():
                        self.channels[newch].source_id[int(source)] = id

            self.log(logarray, 0)

        self.generic_channel_genres = gitdata_dict("generic_channel_genres")
        self.groupslot_names = gitdata_value("groupslot_names", list)
        for index in range(len(self.groupslot_names)):
            self.groupslot_names[index] = re.sub('[-,. ]', '', self.fetch_func.remove_accents(self.groupslot_names[index]).lower().strip())

        self.unknown_program_title = gitdata_value("unknown_program_title", str)
        self.groupslot_names.append(re.sub('[-,. ]', '', self.fetch_func.remove_accents(self.unknown_program_title).lower().strip()))
        self.compat_text = gitdata_value("compat_text", str)
        self.channelprogram_rename = gitdata_dict("channelprogram_rename")
        self.language_texts = gitdata_dict("language_texts")
        self.language_texts['and'] = ' %s ' % (self.language_texts['and'].strip().lower())
        roletrans = gitdata_dict("roletrans")
        self.roletrans = {}
        self.credit_keys = ['credits']
        for k,v in roletrans.items():
            for item in v:
                self.roletrans[item] = k
                self.credit_keys.append(item)
        self.rating = gitdata_dict("rating")
        self.titlerename = gitdata_dict("titlerename")
        self.groupnameremove = gitdata_value("groupnameremove", list)
        self.groupnameremove.sort(key=lambda p: len(p), reverse = True)
        self.episode_exclude_genres = gitdata_value("episode exclude genres", list)
        self.detailed_genres = gitdata_value("detailed_genres", list)
        self.series_genres = gitdata_value("series_genres", list)
        self.movie_genres = gitdata_value("movie_genres", list)
        self.sports_genres = gitdata_value("sports_genres", list)
        self.cattrans_unknown = gitdata_value("cattrans_unknown", str).lower().strip()
        cattrans = gitdata_dict("cattrans")
        for k, v in cattrans.items():
            for item in v:
                if isinstance(item, (str, unicode)):
                    self.cattrans[(item.lower().strip(), '')] = k

                if not isinstance(item,list) or len(item) == 0:
                    continue

                if len(item) == 1:
                    self.cattrans[(item[0].lower().strip(), '')] = k

                else:
                    self.cattrans[(item[0].lower().strip(), item[1].lower().strip())] = k

    # get_json_datafiles()

    def get_channels(self):
        """
        Get a list of all available channels and store these
        in a file.
        """
        for channel in self.channels.values():
            # First we clear out all existing source_id's, because they can have become invalid!
            for index in range(self.source_count):
                channel.source_id[index] = ''

            # These groupids have changed, so to be sure
            if self.opt_dict['always_use_json']:
                channel.group = 99

            # And all not custom set icons
            if self.opt_dict['always_use_json'] and channel.icon_source != 99:
                channel.icon_source = -1
                channel.icon = ''

        db_icon = []
        db_channel = []
        db_channel_source = []
        # These channels contain no data!
        source_keys = {}
        reverse_channels = {}
        if not isinstance(self.channels, dict):
            self.channels = {}

        for chanid, icon in self.xml_output.logo_names.items():
            db_icon.append({'sourceid': icon[0], 'chanid': str(chanid),'icon': icon[1]})

        # Get the sources
        for index in self.sourceid_order:
            self.channelsource[index].init_channel_source_ids()
            if self.channelsource[index].get_channels() == 69:
                self.log(self.text('config',62))
                if not index in self.opt_dict['disable_source']:
                    self.log(self.text('config',63))
                    return 69

            if self.write_info_files:
                self.infofiles.check_new_channels(self.channelsource[index], self.source_channels)

            # a dict with coresponding source, id and chanid
            reverse_channels[index] = {}
            # a list of all ids for the source
            source_keys[index] = []
            for i, v in self.source_channels[index].items():
                reverse_channels[index][v] = {}
                reverse_channels[index][v]['chanid'] = unicode(i)
                i =i.split('-',1)
                reverse_channels[index][v]['source'] = int(i[0])
                reverse_channels[index][v]['chan_scid'] = unicode(i[1])

            for chan_scid in self.channelsource[index].all_channels.keys():
                if not (chan_scid in self.channelsource[index].empty_channels):
                    source_keys[index].append(chan_scid)

        for index in self.sourceid_order:
            self.channelsource[index].init_channel_source_ids()
            for chan_scid, channel in self.channelsource[index].all_channels.items():
                if not is_data_value('name', channel, str, True):
                    continue

                chanid = data_value([index, chan_scid, 'chanid'], reverse_channels, str, '%s-%s' % (index, chan_scid))
                chan ={}
                chan['chanid'] = chanid
                chan['sourceid'] = index
                chan['scid'] = chan_scid
                chan['cgroup'] = data_value('group', channel, int, 99)
                chan['name'] = channel['name']
                chan['fgroup'] = data_value('fetch_grp', channel, None, None)
                chan['hd'] = data_value('HD', channel, bool, False)
                if channel['name'][-3:].lower() == ' hd':
                    chan['hd'] = True

                # These channels are for show, but we like the icons from source 2, 6 and 5!
                if (chan_scid in self.channelsource[index].empty_channels):
                    chan['scid'] = ''
                    chan_scid = ''

                if not chanid in self.channels:
                    if (chan_scid in self.channelsource[index].empty_channels):
                        continue

                    self.channels[chanid] = tv_grab_channel.Channel_Config(self, chanid, chan['name'] )

                self.channels[chanid].source_id[index] = chan_scid
                if self.opt_dict['mark_hd'] and chan['hd']:
                    self.channels[chanid].opt_dict['mark_hd'] = True

                # Set the group
                if ((not self.opt_dict['always_use_json'] and self.channels[chanid].group >= 99)
                    or self.opt_dict['always_use_json']):
                        for g, chan_list in self.channel_grouping.items():
                            if chanid in chan_list:
                                channel['group'] = g
                                break

                if self.channels[chanid].group >= 99:
                    self.channels[chanid].group = data_value('group', channel, int, 99)

                #~ # Move Dutch/Flemish channels from other to main if any sources places them there
                #~ if 'group' in channel and channel['group'] == 1 and self.channels[chanid].group == 7:
                    #~ self.channels[chanid].group = channel['group']

                #~ if 'group' in channel and channel['group'] == 2 and self.channels[chanid].group == 9:
                    #~ self.channels[chanid].group = channel['group']

                #~ # Force Regional radio group
                #~ if 'group' in channel and channel['group'] == 17 and self.channels[chanid].group == 11:
                    #~ self.channels[chanid].group = channel['group']

                # Set the Icon
                icon ={}
                icon['chanid'] = chanid
                if is_data_value('icon', channel, str, True):
                    icon['sourceid'] = data_value('icongrp', channel, int, index)
                    icon['icon'] = channel['icon']
                    db_icon.append(icon)

                elif is_data_value('icon', channel, tuple, True) and is_data_value(['icon', 0], channel, str, True):
                    icon['sourceid'] = channel['icon'][1]
                    icon['icon'] = channel['icon'][0]
                    db_icon.append(icon)

                else:
                    icon['sourceid'] = -1

                for iconsource in self.xml_output.logo_source_preference:
                    if self.channels[chanid].icon_source == iconsource:
                        # A higher preference icon is already set
                        break

                    elif data_value([chanid, 0], self.xml_output.logo_names, int, -1) == iconsource:
                        self.channels[chanid].icon_source = self.xml_output.logo_names[chanid][0]
                        self.channels[chanid].icon = self.xml_output.logo_names[chanid][1]
                        break

                    elif icon['sourceid'] == iconsource:
                        self.channels[chanid].icon_source = icon['sourceid']
                        self.channels[chanid].icon = icon['icon']
                        break

                db_channel_source.append(chan)

        for channel in self.channels.values():
            # Some channel title renaming
            if self.opt_dict['always_use_json'] and channel.chanid in self.channel_rename.keys():
                channel.chan_name = self.channel_rename[channel.chanid]

            # set the default prime_source
            self.validate_option('prime_source', channel, -1)
            db_channel.append({'name': channel.chan_name,
                                               'chanid': channel.chanid,
                                               'cgroup': channel.group})

        self.program_cache.cache_request.put({'task':'add',
                                               'channel': db_channel,
                                               'channelsource': db_channel_source,
                                               'icon': db_icon})
        return 0

    # end get_channels()

    def write_opts_to_log(self):
        """
        Save the the used options to the logfile
        """
        if self.log_output == None:
            return(0)

        log_array = [u'Python version: %s.%s.%s' % (sys.version_info[0], sys.version_info[1], sys.version_info[2])]
        log_array.append(u"%s: %s" % (self.country, self.version(True)))
        log_array.append(u"The Netherlands: %s" % self.version(True, True))
        log_array.append(u"%s: %s" % (self.text('config', 7, type = 'other'), self.language))
        log_array.append(u'Capabilities:"baseline" ,"cache" ,"manualconfig" ,"preferredmethod")')
        log_array.append(u'Preferred Methode: "allatonce"')
        log_array.append(u'log level = %s' % (self.opt_dict['log_level']))
        log_array.append(u'match log level = %s' % (self.opt_dict['match_log_level']))
        log_array.append(u'global_timeout = %s' % (self.opt_dict['global_timeout']))
        log_array.append(u'max_simultaneous_fetches = %s' % (self.opt_dict['max_simultaneous_fetches']))
        log_array.append(u'config_file = %s' % (self.opt_dict['config_file']))
        log_array.append(u'cache_file = %s.db' % (self.opt_dict['cache_file']))
        log_array.append(u'clean_cache = %s' % (self.args.clean_cache))
        log_array.append(u'disable_ttvdb = %s' % (self.opt_dict['disable_ttvdb']))
        log_array.append(u'quiet = %s' % (self.opt_dict['quiet']))
        log_array.append(u'output_file = %s' % (self.opt_dict['output_file']))
        log_array.append(u'output_tz = %s' % (self.opt_dict['output_tz']))
        log_array.append(u'fast = %s' % (self.opt_dict['fast']))
        log_array.append(u'offset = %s' % (self.opt_dict['offset']))
        log_array.append(u'days = %s' % (self.opt_dict['days']))
        log_array.append(u'slowdays = %s' % (self.opt_dict['slowdays']))
        log_array.append(u'compat = %s' % (self.opt_dict['compat']))
        log_array.append(u'legacy_xmltvids = %s' % (self.opt_dict['legacy_xmltvids']))
        log_array.append(u'max_overlap = %s' % (self.opt_dict['max_overlap']))
        log_array.append(u'overlap_strategy = %s' % (self.opt_dict['overlap_strategy']))
        log_array.append(u'logos = %s' % (self.opt_dict['logos']))
        log_array.append(u'desc_length = %s' % (self.opt_dict['desc_length']))
        log_array.append(u'cattrans = %s' % (self.opt_dict['cattrans']))
        log_array.append(u'use_split_episodes = %s' % (self.opt_dict['use_split_episodes']))
        log_array.append(u'ratingstyle = %s' % (self.opt_dict['ratingstyle']))
        log_array.append(u'mark_hd = %s' % (self.opt_dict['mark_hd']))
        log_array.append(u'use_utc = %s' % (self.opt_dict['use_utc']))
        for index in self.source_order:
            if index in self.opt_dict['disable_source']:
                log_array.append(self.text('config', 64, (index, self.channelsource[index].source)))

            elif index in self.opt_dict['disable_detail_source']:
                log_array.append(self.text('config', 65, (index, self.channelsource[index].source)))

        log_array.append(self.text('config', 66))
        for chan_def in self.channels.values():
            if not (chan_def.active or chan_def.is_child):
                continue

            log_array.append(u'[%s (Chanid=%s)]\n' % (chan_def.chan_name, chan_def.chanid))
            if chan_def.opt_dict['xmltvid_alias'] != None:
                log_array.append(u'  xmltvID_alias = %s\n' % (chan_def.opt_dict['xmltvid_alias']))

            src_id = chan_def.opt_dict['prime_source']
            log_array.append(u'  prime_source = %s (%s)\n' % (src_id, self.channelsource[src_id].source))
            if not self.opt_dict['always_use_json'] and chan_def.chanid in self.prime_source and self.prime_source[chan_def.chanid] != src_id:
                log_array.append(self.text('config', 67 ,(self.prime_source[chan_def.chanid], self.channelsource[self.prime_source[chan_def.chanid]].source)))

            for index in chan_def.opt_dict['disable_source']:
                if index in self.opt_dict['disable_source']:
                    continue

                log_array.append(self.text('config', 68, (index, self.channelsource[index].source)))

            for index in chan_def.opt_dict['disable_detail_source']:
                if index in chan_def.opt_dict['disable_source'] or index in self.opt_dict['disable_source'] or index in self.opt_dict['disable_detail_source']:
                    continue

                log_array.append(self.text('config', 69, (index, self.channelsource[index].source)))

            src_id = chan_def.opt_dict['prefered_description']
            if src_id != -1:
                if chan_def.get_source_id(src_id) != '':
                    log_array.append(u'  prefered_description = %s (%s)\n' % (src_id, self.channelsource[src_id].source))

            if chan_def.opt_dict['add_hd_id']:
                log_array.append(u'  add_hd_id = True\n')

            elif chan_def.opt_dict['mark_hd']:
                log_array.append(u'  mark_hd = True\n')

            if chan_def.opt_dict['slowdays'] != self.opt_dict['slowdays'] and chan_def.opt_dict['slowdays'] != None:
                log_array.append(u'  slowdays = %s' % (chan_def.opt_dict['slowdays']))

            for val in ( 'fast', 'compat', 'legacy_xmltvids', 'max_overlap', 'overlap_strategy', \
              'logos', 'desc_length', 'cattrans', 'disable_ttvdb', 'use_split_episodes'):
                if chan_def.opt_dict[val] != self.opt_dict[val]:
                    log_array.append(u'  %s = %s\n' % (val, chan_def.opt_dict[val]))

        log_array.append(u' \n')
        self.log(log_array, 1, 2)

    # end write_opts_to_log()

    def write_config(self, add_channels = None):
        """
        Save the channel info and the default options
        if add_channels is False or None we copy over the Channels sections, called on save_options
        If add_channels is None we convert the channel info to the new form, called on version update
        if add_channels is True we create a fresh channels section                , called on configure
        """
        self.IO_func.save_oldfile(self.opt_dict['config_file'])
        f = self.IO_func.open_file(self.opt_dict['config_file'], 'w')
        if f == None:
            return False

        f.write(u'# encoding: utf-8\n')
        f.write(u'# configversion: %s.%s%s\n' % (self.api_major + 2, self.api_minor, '{:0>2}'.format(self.api_patch)))
        f.write(u'\n')

        # Save the options
        for i in range(1, 10):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'\n')
        f.write(u'[%s]\n' % self.__CONFIG_SECTIONS__[1])
        f.write(u'language = %s\n' % self.lang)
        f.write(self.text('config', 0, type = 'confighelp'))
        f.write(u'data_version = %s\n' % self.opt_dict['data_version'])
        for i in range(11, 16):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'always_use_json = %s\n' % self.opt_dict['always_use_json'])
        f.write(u'group_active_channels = %s\n' % self.opt_dict['group_active_channels'])
        if self.write_info_files:
            f.write(u'write_info_files = True\n')
            if self.opt_dict['mail_log'] and self.opt_dict['mail_info_address'] != None:
                f.write(u'mail_info_address = %s\n' % self.opt_dict['mail_info_address'])

            f.write(u'\n')

        for i in range(21, 39):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'global_timeout = %s\n' % self.opt_dict['global_timeout'])
        f.write(u'max_simultaneous_fetches = %s\n' % self.opt_dict['max_simultaneous_fetches'])
        f.write(u'\n')
        for i in range(41, 52):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'log_level = %s\n' % self.opt_dict['log_level'])
        for i in range(61, 67):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'match_log_level = %s\n' % self.opt_dict['match_log_level'])
        f.write(u'\n')
        f.write(u'mail_log = %s\n' % self.opt_dict['mail_log'])
        for i in range(71, 77):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'mail_log_address = %s\n' % self.opt_dict['mail_log_address'])
        f.write(u'mailserver = %s\n' % self.opt_dict['mailserver'])
        f.write(u'mailport = %s\n' % self.opt_dict['mailport'])
        f.write(u'\n')
        f.write(u'quiet = %s\n' % self.opt_dict['quiet'])
        f.write(u'output_file = %s\n' % self.opt_dict['output_file'])
        f.write(u'output_tz = %s\n' % self.opt_dict['output_tz'])
        for index in self.source_order:
            if index in self.opt_dict['disable_source']:
                f.write(u'disable_source = %s\n' % index)

            elif index in self.opt_dict['disable_detail_source']:
                f.write(u'disable_detail_source = %s\n' % index)

        f.write(u'disable_ttvdb = %s\n' % self.opt_dict['disable_ttvdb'])
        f.write(u'compat = %s\n' % self.opt_dict['compat'])
        f.write(u'legacy_xmltvids = %s\n' % self.opt_dict['legacy_xmltvids'])
        f.write(u'logos = %s\n' % self.opt_dict['logos'])
        f.write(u'use_utc = %s\n' % self.opt_dict['use_utc'])
        f.write(u'fast = %s\n' % self.opt_dict['fast'])
        f.write(u'offset = %s\n' % self.opt_dict['offset'])
        f.write(u'days = %s\n' % self.opt_dict['days'])
        f.write(u'slowdays = %s\n' % self.opt_dict['slowdays'])
        f.write(u'cattrans = %s\n' % self.opt_dict['cattrans'])
        f.write(u'mark_hd = %s\n' % self.opt_dict['mark_hd'])
        f.write(u'overlap_strategy = %s\n' % self.opt_dict['overlap_strategy'] )
        f.write(u'max_overlap = %s\n' % self.opt_dict['max_overlap'])
        f.write(u'desc_length = %s\n' % self.opt_dict['desc_length'])
        for i in range(81, 87):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'ratingstyle = %s\n' % self.opt_dict['ratingstyle'])
        f.write(u'use_split_episodes = %s\n' % self.opt_dict['use_split_episodes'])
        f.write(u'\n')
        for i in range(91, 139):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        def get_channel_string(chanid, active = None, chan_string = None, icon_string = None):
            chan = self.channels[chanid]
            for index in range(self.source_count):
                if chan.get_source_id(index) != '':
                    break

            else:
                # There are no Source ids so we remove it
                return {'chan_string': None, 'active': None}

            if active == None:
                active = chan.active

            if chan_string == None:
                chan_string = '%s;%s;%s' % (chan.chan_name, chan.group, chanid)

            for index in range(self.source_count):
                chan_string = '%s;%s' % (chan_string, chan.get_source_id(index))

            if icon_string == None:
                chan_string = '%s;%s;%s\n' % (chan_string, chan.icon_source, chan.icon)

            else:
                chan_string = '%s;%s\n' % (chan_string, icon_string)

            if active:
                return {'chan_string': chan_string, 'active': active}

            else:
                return {'chan_string': '# %s' % chan_string, 'active': active}

        # just copy over the channels section
        if add_channels == False and self.configversion == float('%s.%s' % (self.api_major+2, self.api_minor)):
            fo = self.IO_func.open_file(self.opt_dict['config_file'] + '.old')
            if fo == None or not self.IO_func.check_encoding(fo):
                # We cannot read the old config, so we create a new one
                self.log(self.text('config', 70))
                add_channels = True

            else:
                self.encoding = self.IO_func.encoding
                fo.seek(0,0)
                type = 0
                for byteline in fo.readlines():
                    line = self.IO_func.get_line(fo, byteline, None)
                    try:
                        if  line == False:
                            continue

                        # Look for section headers
                        config_title = re.search('\[(.*?)\]', line)
                        if config_title != None and (config_title.group(1) in self.__CONFIG_SECTIONS__.values()):
                            for i, v in self.__CONFIG_SECTIONS__.items():
                                if v == config_title.group(1):
                                    type = i
                                    break

                        elif config_title != None and (config_title.group(1)[0:8] == 'Channel '):
                            type = 9

                        # Unknown Section header, so ignore
                        if line[0:1] == '[':
                            type = 0
                            continue

                        if type > 1:
                            # We just copy everything except the old configuration (type = 1)
                            f.write(line + u'\n')
                    except:
                        self.log(self.text('config', 71))
                        continue

                fo.close()
                f.close()
                return True

        # This is an upgrade
        chan_not_updated = []
        if add_channels != True:
            configlines = {}
            configlines['2remarks'] = []
            configlines['2'] = []
            configlines['3remarks'] = []
            configlines['3'] = []
            configlines['9'] = {}
            # Get the old channels section to convert
            fo = self.IO_func.open_file(self.opt_dict['config_file'] + '.old')
            if fo == None or not self.IO_func.check_encoding(fo, None, True):
                # We cannot read the old config, so we create a new one
                self.log(self.text('config', 70))
                self.get_channels()
                add_channels = True

            else:
                self.encoding = self.IO_func.encoding
                self.configversion = self.IO_func.configversion
                fo.seek(0,0)
                if self.configversion == 1.0:
                    type = 2

                else:
                    type = 0

                # Read the old configuration
                for byteline in fo.readlines():
                    line = self.IO_func.get_line(fo, byteline, None, self.encoding)
                    try:
                        if line == '# encoding: utf-8' or line[0:17] == '# configversion: ' or line == False or line == '':
                            continue

                        if self.configversion != 1.0:
                            # Look for section headers
                            config_title = re.search('\[(.*?)\]', line)
                            if config_title != None and (config_title.group(1) in self.__CONFIG_SECTIONS__.values()):
                                section = config_title.group(1)
                                for i, v in self.__CONFIG_SECTIONS__.items():
                                    if v == config_title.group(1):
                                        type = i
                                        continue

                                continue

                            elif config_title != None and (config_title.group(1)[0:8] == 'Channel '):
                                section = config_title.group(1)
                                type = 9
                                chanid = config_title.group(1)[7:].strip()
                                configlines['9'][chanid] = []
                                continue

                            # Unknown Section header, so ignore
                            if line[0:1] == '[' or re.sub('#', '', line).strip() == u'Channel specific settings other then the above or the default:':
                                type = 0
                                continue

                        if type == 2 and self.configversion <= 2.0:
                            if line[0:1] == '#':
                                configlines['2remarks'].append(line)

                            else:
                                configlines['2'].append(line)

                        elif type == 3 and self.configversion > 2.0:
                            if line[0:1] == '#':
                                configlines['3remarks'].append(line)

                            else:
                                configlines['3'].append(line)

                        elif type == 9 and self.configversion > 2.0:
                            configlines['9'][chanid].append(line)

                    except:
                        self.log(self.text('config', 71))
                        continue

                fo.close()

                self.get_channels()
                chan_added = []
                chan_list = {}
                for g in self.group_order:
                    chan_list[unicode(g)] =[]

                if self.configversion <= 2.0:
                    for item in configlines['2']:
                        chan = item.split(None, 1) # split on first whitespace
                        if len(chan) != 2:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        if chan[0].strip() in self.channels.keys():
                            chanid = chan[0].strip()
                            grp = u'0' if self.args.group_active_channels else unicode(self.channels[chanid].group)
                            chan_list[grp].append(get_channel_string(chanid, True, '%s;%s;%s' % \
                                (chan[1], self.channels[chanid].group, chanid)))
                            chan_added.append(chanid)

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                    for item in configlines['2remarks']:
                        chan = re.sub('#', '', item)
                        chan = chan.split(None, 1) # split on first whitespace
                        if len(chan) != 2:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        if chan[0].strip() in self.channels.keys():
                            chanid = chan[0].strip()
                            chan_list[unicode(self.channels[chanid].group)].append(get_channel_string(chanid, False, '%s;%s;%s' % \
                                (chan[1], self.channels[chanid].group, chanid)))
                            chan_added.append(chanid)

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                if self.configversion > 2.0:
                    for item in configlines['3']:
                        chan = re.split(';', item)
                        if self.configversion == 2.1 and len(chan) != 8:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        chan_found = False
                        for chanid, channel in self.channels.items():
                            for index in range(min(self.source_count,len(chan) - 4)):
                                if (chan[index + 2].strip() !='') and (chan[index + 2].strip() == channel.get_source_id(index)):
                                    chan_found = True
                                    grp = u'0' if self.args.group_active_channels else chan[1]
                                    chan_list[grp].append(get_channel_string(chanid, True, '%s;%s;%s' % \
                                        (chan[0], chan[1], chanid), '%s;%s' % (chan[-2], chan[-1])))
                                    chan_added.append(chanid)
                                    chan_found = True
                                    break

                            if chan_found:
                                break

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                    for item in configlines['3remarks']:
                        chan = re.sub('#', '', item)
                        if chan.strip() in self.group_order:
                            continue

                        chan = re.split(';', chan)
                        if self.configversion == 2.1 and len(chan) != 8:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        chan_found = False
                        for chanid, channel in self.channels.items():
                            for index in range(min(self.source_count,len(chan) - 4)):
                                if (chan[index + 2].strip() !='') and (chan[index + 2].strip() == channel.get_source_id(index)):
                                    chan_list[chan[1]].append(get_channel_string(chanid, False, '%s;%s;%s' % \
                                        (chan[0], chan[1], chanid), '%s;%s' % (chan[-2], chan[-1])))
                                    chan_added.append(chanid)
                                    chan_found = True
                                    break

                            if chan_found:
                                break

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                del configlines['2']
                del configlines['3']
                del configlines['2remarks']
                del configlines['3remarks']
                for chanid, channel in self.channels.items():
                    if not chanid in chan_added:
                        chan_list[unicode(channel.group)].append(get_channel_string(chanid, False))

                # At a later config upgrade we here have to parse the type 9 sections

        if add_channels:
            chan_list = {}
            for g in self.group_order:
                chan_list[unicode(g)] =[]

            for chanid, channel in self.channels.items():
                grp = u'0' if self.args.group_active_channels and channel.active else unicode(channel.group)
                chan_list[grp].append(get_channel_string(chanid))

        f.write(u'[%s]\n' % self.__CONFIG_SECTIONS__[3])
        for g in self.group_order:
            if g == 0 and not self.opt_dict['group_active_channels']:
                continue

            f.write(u'\n')
            f.write(u'# %s\n' % self.chan_groups[g])
            chan_list[unicode(g)].sort(key=lambda channel: (channel['chan_string']))
            chan_list[unicode(g)].sort(key=lambda channel: (channel['active']), reverse=True)
            for channel in chan_list[unicode(g)]:
                if channel['chan_string'] != None:
                    f.write(channel['chan_string'])

        if len(chan_not_updated) > 0:
            f.write(u'\n')
            f.write(u'# Following are not converted lines!\n')
            for line in chan_not_updated:
                f.write(line)

        f.write(u'\n')
        f.write(u'# Channel specific settings other then the above or the default:\n')
        chan_names = []
        for chan_def in self.channels.values():
            for index in range(self.source_count):
                if chan_def.get_source_id(index) != '':
                    # Only add specific settings if at least one sourceid present
                    chan_names.append({'active': chan_def.active, 'name': chan_def.chan_name, 'id': chan_def.chanid})
                    break

        chan_names.sort(key=lambda channel: (channel['name']))
        chan_names.sort(key=lambda channel: (channel['active']), reverse=True)

        for chan in chan_names:
            chan_def = self.channels[chan['id']]
            chan_name_written = False
            for index in chan_def.opt_dict['disable_source']:
                if index in self.opt_dict['disable_source']:
                    continue

                if index in chan_def.source_id.keys() and chan_def.get_source_id(index) != '':
                    if not chan_name_written:
                        f.write(u'\n')
                        f.write(u'# %s\n' % (chan_def.chan_name))
                        f.write(u'[Channel %s]\n' % (chan_def.chanid))
                        chan_name_written = True

                    f.write(u'disable_source = %s\n' % index)

            for index in chan_def.opt_dict['disable_detail_source']:
                if index in chan_def.opt_dict['disable_source'] or index in self.opt_dict['disable_source'] or index in self.opt_dict['disable_detail_source']:
                    continue

                if index in chan_def.source_id.keys() and chan_def.get_source_id(index) != '':
                    if not chan_name_written:
                        f.write(u'\n')
                        f.write(u'# %s\n' % (chan_def.chan_name))
                        f.write(u'[Channel %s]\n' % (chan_def.chanid))
                        chan_name_written = True

                    f.write(u'disable_detail_source = %s\n' % index)

            if chan_def.opt_dict['xmltvid_alias'] != None and chan_def.opt_dict['xmltvid_alias'] != chan_def.chanid:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'xmltvid_alias = %s\n' % (chan_def.opt_dict['xmltvid_alias']))

            if not self.validate_option('prime_source', chan_def, check_default = True):
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'prime_source = %s\n' % chan_def.opt_dict['prime_source'])

            opt_val = chan_def.opt_dict['prefered_description']
            if opt_val in chan_def.source_id.keys() and chan_def.get_source_id(opt_val) != '':
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'prefered_description = %s\n' % ( opt_val))

            if chan_def.opt_dict['add_hd_id']:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'add_hd_id = True\n')

            if chan_def.opt_dict['slowdays'] != self.opt_dict['slowdays'] and chan_def.opt_dict['slowdays'] != None:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'slowdays = %s\n' % (chan_def.opt_dict['slowdays']))

            if self.opt_dict['disable_ttvdb'] == False and chan_def.opt_dict['disable_ttvdb'] == True:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'disable_ttvdb = True\n')

            for val in ( 'fast', 'compat', 'legacy_xmltvids', 'max_overlap', 'overlap_strategy', \
              'logos', 'desc_length', 'cattrans', 'mark_hd', 'use_split_episodes'):
                if chan_def.opt_dict[val] != self.opt_dict[val]:
                    if not chan_name_written:
                        f.write(u'\n')
                        f.write(u'# %s\n' % (chan_def.chan_name))
                        f.write(u'[Channel %s]\n' % (chan_def.chanid))
                        chan_name_written = True

                    f.write(u'%s = %s\n' % (val, chan_def.opt_dict[val]))

        f.close()
        return True
    # end write_config()

    def write_defaults_list(self):
        """
        Save the genre conversion table, the title split exception list and othe translation tables
        """
        self.IO_func.save_oldfile(self.opt_dict['settings_file'])
        f = self.IO_func.open_file(self.opt_dict['settings_file'], 'w')
        if f == None:
            return False

        f.write(u'# encoding: utf-8\n')
        f.write(u'\n')
        for i in range(141, 145):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[2])

        self.notitlesplit.sort()
        for t in self.notitlesplit:
             f.write(u'%s\n' % t)

        f.write(u'\n')
        for i in range(146, 149):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(self.text('config', 152, type = 'confighelp'))
        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[3])

        self.groupnameremove.sort(key=lambda p: len(p), reverse = True)
        for t in self.groupnameremove:
             f.write(u'%s\n' % t)

        f.write(u'\n')
        for i in range(150, 153):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[4])

        l = []
        for i, t in self.titlerename.iteritems():
            l.append(u'%s = %s\n' % (i,t))
        l.sort()
        for string in l:
            f.write(string)

        f.write(u'\n')
        for i in range(154, 159):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[5])

        l = []
        self.detailed_genres.sort()
        for dg in self.detailed_genres:
             f.write(u'%s\n' % dg)

        if len(self.cattranstype[1]) > 0:
            slist = u'# '
            for s in self.cattranstype[1].values():
                slist = u'%s%s, ' % (slist, self.channelsource[s].source)

            slist = u'%s genres\n' % (slist[0:-2])
            f.write(u'\n')
            f.write(self.text('config', 160, type = 'confighelp'))
            f.write(slist)
            for i in range(161, 163):
                line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
                if line != '':
                    f.write(line)

            ctlist = list(self.cattranstype[1].keys())
            ctlist.sort()
            for index in ctlist:
                source = self.channelsource[self.cattranstype[1][index]]
                f.write(u'\n')
                f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[index])

                # remove doubles and sort
                for (k1, k2), v in source.new_cattrans.items():
                    if not (k1 in source.cattrans.keys()):
                        source.cattrans[k1] = {}
                        source.cattrans[k1]['default'] = [self.cattrans_unknown.lower().strip(),'']
                        source.cattrans[k1][k2] = v

                    elif not k2 in source.cattrans[k1]:
                        source.cattrans[k1][k2] = v

                # format for export
                gl1 = []
                gl = []
                for k, v in source.cattrans.items():

                    for sg in v.keys():
                        if sg == 'default':
                            gl1.append(u'%s: = %s: %s\n' % (k.strip().lower(), v[sg][0].strip().lower(), v[sg][1].strip().lower()))

                        else:
                            gl.append(u'%s: %s = %s: %s\n' % (k.strip().lower(), sg.strip().lower(), v[sg][0].strip().lower(), v[sg][1].strip().lower()))

                gl1.sort()
                for string in gl1:
                    f.write(string)

                gl.sort()
                for string in gl:
                    f.write(string)

        if len(self.cattranstype[2]) > 0:
            slist = u''
            for s in self.cattranstype[2].values():
                slist = u'%s%s, ' % (slist, self.channelsource[s].source)

            f.write(u'\n')
            f.write(self.text('config', 164, type = 'confighelp'))
            f.write(self.text('config', 165, (slist[0:-2], ), type = 'confighelp'))
            for i in range(166, 168):
                line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
                if line != '':
                    f.write(line)

            ctlist = list(self.cattranstype[2].keys())
            ctlist.sort()
            for index in ctlist:
                source = self.channelsource[self.cattranstype[2][index]]
                f.write(u'\n')
                f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[index])
                # remove doubles and sort
                gs = set(source.new_cattrans)
                gl = []
                for k, v in gs:
                    if not (k in source.cattrans):
                        source.cattrans[k] = v

                # format for export
                for k, v in source.cattrans.iteritems():
                    gl.append(u'%s = %s\n' % (v, k))
                gl.sort()

                for string in gl:
                    f.write(string)

        f.write(u'\n')
        f.write(self.text('config', 169, type = 'confighelp'))
        f.write(u'# \n')
        for i in range(170, 175):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'# \n')
        for i in range(176, 184):
            line = self.text('config', i, type = 'confighelp', return_empty_on_missing = True)
            if line != '':
                f.write(line)

        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[1])

        l1 = []
        l2 = []

        # remove doubles
        gs = set(self.genre_list)
        # add them to cattrans if not yet known
        for i in gs:
            if not (i in self.cattrans):
                self.cattrans[i]=''

        # format for export and add main genres and sub-genres to seperate lists to get sorted
        # add missing maingenres for new subgenres
        for k1, k2 in self.cattrans:
            if k2 == '':
                l1.append(u'%s: = %s\n' % (k1, self.cattrans[(k1,k2)]))
            else:
                l2.append(u'%s: %s = %s\n' % (k1, k2, self.cattrans[(k1,k2)]))
                i = (k1, u'')
                if not (i in self.cattrans):
                    l1.append(u'%s:=\n' % k1)
        l1.sort()
        l2.sort()

        for string in l1:
            f.write(string)

        f.write(u'\n')
        for string in l2:
            f.write(string)

        f.close()
    # end write_defaults_list()

    def write_statistics(self, start, end):
        log_array = ['\n', self.text('config', 72, type = 'stats'), '\n']
        log_array.append(self.text('config', 73, (self.xml_output.program_count, self.chan_count), type = 'stats'))
        log_array.append(self.text('config', 74, (self.in_output_tz(start).strftime('%Y-%m-%d %H:%M'), ), type = 'stats'))
        log_array.append(self.text('config', 75, (self.in_output_tz(end).strftime('%Y-%m-%d %H:%M'), ), type = 'stats'))
        log_array.append(self.text('config', 76, (end - start, ), type = 'stats'))
        fetch_count = self.fetch_func.get_counter('base', 'total') \
                            + self.fetch_func.get_counter('detail', 'total') \
                            + self.fetch_func.get_counter('jsondata', 'total')
        fetch_fail = self.fetch_func.get_counter('fail', 'total') \
                            + self.fetch_func.get_counter('failjson', 'total')
        log_array.append( self.text('config', 77, (fetch_count, fetch_fail), type = 'stats'))
        log_array.append(self.text('config', 78, (self.fetch_func.get_counter('detail', -99), ), type = 'stats'))
        log_array.append(self.text('config', 79, (self.fetch_func.get_counter('lookup', -1), ), type = 'stats'))
        log_array.append(self.text('config', 80, (self.fetch_func.get_counter('lookup_fail', -1), ), type = 'stats'))
        if self.args.only_cache:
            self.log(log_array, 1, 3)
            return

        if fetch_count > 0:
            log_array.extend([self.text('config', 81, ((end - start).total_seconds()/fetch_count, ), type = 'stats'), '\n'])
        log_array.append(self.text('config', 82, (self.fetch_func.get_counter('detail', -1), ), type = 'stats'))
        log_array.extend([self.text('config', 83, (self.fetch_func.get_counter('fail', -1), ), type = 'stats'), '\n'])
        for s, source in self.channelsource.items():
            if source.detail_processor:
                log_array.append(self.text('config', 84, (self.fetch_func.get_counter('base', s), source.source), type = 'stats'))
                log_array.append(self.text('config', 85, (self.fetch_func.get_counter('detail', s), source.source), type = 'stats'))
                log_array.extend([self.text('config', 86, (self.fetch_func.get_counter('fail', s), source.source), type = 'stats'), '\n'])

        for s, source in self.channelsource.items():
            if not (source.is_virtual or source.detail_processor):
                log_array.append(self.text('config', 84, (self.fetch_func.get_counter('base', s), source.source), type = 'stats'))
                log_array.extend([self.text('config', 86, (self.fetch_func.get_counter('fail', s), source.source), type = 'stats'), '\n'])

        self.log(log_array, 4, 3)
    # write_statistics()

    def close(self):
        try:
            if self.infofiles != None:
                self.infofiles.close(self.channels, self.combined_channels, self.channelsource)

        except:
            self.logging.log_queue.put({'fatal': [traceback.format_exc(), '\n'], 'name': 'InfoFiles'})
            self.ready = True

        if self.program_cache != None and self.program_cache.is_alive():
            self.program_cache.cache_request.put({'task':'quit'})
            self.program_cache = None

        if self.ttvdb != None and self.ttvdb.is_alive():
            self.ttvdb.detail_request.put({'task':'quit'})
            self.ttvdb = None

        # close everything neatly
        if self.opt_dict['output_file'] != None:
            try:
                self.output.close()

            except:
                pass

        self.logging.log_queue.put('Closing down\n')
        if self.logging.is_alive():
            self.logging.join()

        if self.log_output != None:
            self.log_output.close()

    # end close()

# end Configure()
